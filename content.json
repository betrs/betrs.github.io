[{"title":"webpack提取公共代码及js，css的分离操作","date":"2017-06-20T13:12:01.000Z","path":"2017/06/20/webpack-fl/","text":"其实早就想和大家分享下webpack，由于最近较忙正在搞一个桌面应用，所以抽空给大家聊聊webpack的独立打包。相信点开此文章的朋友都已经接触过webpack了，所以在这咱们也不废话了，基础知识咱不讲解，这里咱们就直杀主题了，如果是没有基础的朋友建议可以先了解一下webpack的打包过程，当然我也不会完全不去管没有基础的朋友，下面我也会说一下关于webpack配置方面的说明，好了，下面咱们直接先上代码，然后我来给各位一一剖解： var webpack = require(&apos;webpack&apos;); var path = require(&quot;path&quot;); var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;); module.exports = { entry:{ main:&quot;./src/index.js&quot;, vendor:[&quot;jquery&quot;] }, output:{ filename:&quot;js/[name].[chunkhash:5].js&quot;, path: path.resolve(__dirname,&quot;dist&quot;) }, module:{ rules:[ { test:/\\.css$/, loader:ExtractTextPlugin.extract({ fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot;, publicPath: &quot;/dist&quot; }), exclude: /node_modules/ } ] }, plugins:[ //提取公共代码插件 new webpack.optimize.CommonsChunkPlugin({ names: [&apos;vendor&apos;,&apos;manifest&apos;] }), new HtmlWebpackPlugin({ title: &apos;webpack&apos;, inject:&quot;head&quot;, template: &apos;index.html&apos; // 模板路径 }), new ExtractTextPlugin(&quot;css/style.css&quot;) ] } 以上是我们整个配置文件代码，下面我来从上至下的给大家讲解一下其配置意思：entry指的是webpack打包的入口，在配置中我们可以看到它的值是一个对象，其实入口的值有三种形式：第一种是字符串，第二种是数组，第三种是对象，对象的意思是指我们需要多个文件打包，目的是为了打包后希望我们的js不要把两个入口的代码写入到一个文件当中去，然后入口中打包的两个东西一个是我们程序的入口文件，一个是jq框架，这里vendor属性用于配置打包第三方类库，写入数组的类库名将统一打包到一个文件里面去，所以这是框架的独立打包，其目的是为了让我们的业务代码不要与框架代码给混在一起，这样不适于我们后期的程序管理。下面我们先看看程序入口文件中的代码： import $ from &quot;jquery&quot;; import &quot;./style/style.css&quot;; const setbg =()=&gt;{ $(&quot;body&quot;).html(&quot;吴佳&quot;); } setbg(); 以上是程序的入口文件代码，我们需要注意其中引入了一个css文件，下面我再把css文件内的代码给先贴出来： body{ color:red; background: blue; font-size: 30px; } 代码很简单，就不作讲解了，具体我等会再说为啥把这两个文件代码贴出来，现在咱们把配置文件中的代码接着往下扯，后面我们扯到的是输出，output，它指的webpack打包生成后的文件输出位置及文件名字的配置，我们可以看到它的值也是一个对象，其中filename指的是输出打包生成文件后的文件名字，path是指输出存放文件的位置。可以看到filename值也就是打包生成的文件名字是动态生成，由[name].[chunkhash:5]组成，[name]的意思是指对应于入口配置处需打包文件的键名，[chunkhash:5]指的是打包后生成的版本hash值，:5的意思是指取hash长度5位数，path属性可以看到我们把生成文件输出到了项目的根目录中的dist文件目录下面去了，然后内部创建了一个js的文件目录，其中放入的就是我们打包生成后的所有js文件。这里module rules属性是一个数组，保存每一个要用到的加载器的配置，我们就在这里添加css-loader。每一个加载器，至少要配置两个选项：test和loader。test一般是一个正则表达式，用于测试每个文件的绝对路径，多数情况下，这里的正则表达式都是用于检测文件的扩展名，比如/.css$/检测文件名是不是以.css结尾，然后需要指定loader，也就是指定对通过test检测的文件应用什么加载器，exclude属性，指定要排除的文件夹，exclude的值应该是一个正则表达式，因此这里设置为/node_modules/。plugins是插件配置项，值是一个数组，数组内部每一项代表一个插件的实例，在此配置中我们用到了三个插件：webpack.optimize.CommonsChunkPlugin提取公共代码插件，HtmlWebpackPlugin模板插件，ExtractTextPlugin分离css插件。 提取公共代码插件我们是用它来给我们项目提取js的公共代码用的，在插件配置中我们传入了一个names属性是设置需提取的公共代码部分值是一个数组，vendor代表提取入口设置的所有插件项打包生成到一个文件当中，最后会生成一个叫vendor这个键名的js文件也就是所有框架或者插件的打包文件，由于提取第三方类库时我们没有改动第三方库代码但打包时还是会生成一个新的hash值，为了解决此问题我们给插件添加一个提取属性’manifest’，manifest.js为webpack的启动文件代码，它会直接影响到hash值，用mainfest单独抽出来了，这样vendor的hash就不会变了。 模板插件可以简化创建调用webpack bundles的html文件。在每次编译后，文件名会包含有hash值的bundles 特别有用。你可以让插件为您生成一个HTML文件，也可以提供您自己使用lodash模板的模板或使用您自己的装载机。你可以传一个配置选项的散列到 HtmlWebpackPlugin，允许的值如下： title : ,//用于生成的HTML文件的标题。 filename : ,//用于生成的HTML文件的名称，默认是index.html。你可以在这里指定子目录（例如:assets/admin.html） template : ,//模板的路径。支持加载器，例如 html!./index.html。 inject :true | ‘head’ | ‘body’ | false ,//把所有产出文件注入到给定的 template 或templateContent。当传入 true或者 ‘body’时所有javascript资源将被放置在body元素的底部，“head”则会放在head元素内。 favicon : ,//给定的图标路径，可将其添加到输出html中。 minify : {…} | false ,//传一个html-minifier 配置object来压缩输出。 hash : true | false,//如果是true，会给所有包含的script和css添加一个唯一的webpack编译hash值。这对于缓存清除非常有用。 cache : true | false ,//如果传入true（默认），只有在文件变化时才 发送（emit）文件。 showErrors : true | false ,//如果传入true（默认），错误信息将写入html页面。 chunks : ,//只允许你添加chunks （例如：只有单元测试块 ） chunksSortMode : ,//在chunk被插入到html之前，你可以控制它们的排序。允许的值 ‘none’ | ‘auto’ | ‘dependency’ | {function}默认为‘auto’. excludeChunks :,// 允许你跳过一些chunks（例如，不要单元测试的 chunk）. xhtml :,// 用于生成的HTML文件的标题。 title : true | false,//如果是true，把link标签渲染为自闭合标签，XHTML要这么干的。默认false。 分离css插件主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象;该插件有三个参数意义分别如下: use:,//指需要什么样的loader去编译文件,这里由于源文件是.css所以选择css-loader fallback:,//编译后用什么loader来提取css文件 publicfile:,//用来覆盖项目路径,生成该css文件的文件路径 以上是整个配置的讲解，最终webpack打包输出后在dist目录内有一个js目录一个css目录和一个index.html模板，js目录内分别有三个js文件main.hash.js，vendor.hash.js，manifest.hash.js，css目录内有一个style.css文件，它们会自动被引入到index.html 的head标签中，css文件是由打包index.js程序入口时分离出来的文件并输出到css目录当中去的。","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"flex弹性盒模型12个属性解读","date":"2017-05-26T15:00:34.000Z","path":"2017/05/26/flex-layout/","text":"#什么是flex布局? Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 例如： .box{ display: flex; } 行内元素也可以使用Flex布局。 .box{ display: inline-flex; } #基本概念： 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 注意：设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 #容器的属性： 以下6个属性设置在父容器上： 1. flex-direction 2. flex-wrap 3. flex-flow 4. justify-content 5. align-items 6. align-content ##第一个属性： flex-direction属性决定主轴的方向（即项目的排列方向）。 ##它可能有4个值： （1）row（默认值）：主轴为水平方向，起点在左端。 （2）row-reverse：主轴为水平方向，起点在右端。 （3）column：主轴为垂直方向，起点在上沿。 （4）column-reverse：主轴为垂直方向，起点在下沿。 ##第二个属性： flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 它可能取三个值： （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 ##第三个属性： flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 例如： .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } ##第四个属性： justify-content属性定义了项目在主轴上的对齐方式。 它可能取5个值：（具体对齐方式与轴的方向有关。下面假设主轴为从左到右） （1）flex-start（默认值）：左对齐 （2）flex-end：右对齐 （3）center： 居中 （4）space-between：两端对齐，项目之间的间隔都相等。 （5）space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 ##第五个属性： align-items属性定义项目在交叉轴上如何对齐。 它可能取5个值：（具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下） （1）flex-start：交叉轴的起点对齐。 （2）flex-end：交叉轴的终点对齐。 （3）center：交叉轴的中点对齐。 （4）baseline: 项目的第一行文字的基线对齐。 （5）stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 ##第六个属性： align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 该属性可能取6个值： （1）flex-start：与交叉轴的起点对齐。 （2）flex-end：与交叉轴的终点对齐。 （3）center：与交叉轴的中点对齐。 （4）space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 （5）space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 （6）stretch（默认值）：轴线占满整个交叉轴。 #项目(子盒子)的属性： 以下6个属性设置在（子盒子）项目上： 1. order 2. flex-grow 3. flex-shrink 4. flex-basis 5. flex 6. align-self ##第一个属性： order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 例如： .item { order: &lt;integer&gt;; } ##第二个属性： flex-grow 属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 例如： .item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 ##第三个属性： flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 例如： .item { flex-shrink: &lt;number&gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 ##第四个属性： flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（mainsize）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 例如： .item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 ##第五个属性： flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 例如： .item { flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 ##第六个属性： align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 例如： .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","tags":[{"name":"CSS3","slug":"CSS3","permalink":"http://yoursite.com/tags/CSS3/"}]},{"title":"ES6/ES2015核心内容","date":"2017-01-05T05:06:32.000Z","path":"2017/01/05/es6core/","text":"ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 也就是说，ES6就是ES2015。 虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算你现在不打算使用ES6，但为了看懂别人的你也该懂点ES6的语法了… 在我们正式讲解ES6语法之前，我们得先了解下Babel。 Babel Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看： #最常用的ES6特性 let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。 #let, const 这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。首先来看下面这个例子： var name = &apos;zach&apos; while (true) { var name = &apos;obama&apos; console.log(name) //obama break } console.log(name) //obama 使用var 两次输出都是obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。 let name = &apos;zach&apos; while (true) { let name = &apos;obama&apos; console.log(name) //obama break } console.log(name) //zach 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子： var a = []; for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。 var clickBoxs = document.querySelectorAll(&apos;.clickBox&apos;) for (var i = 0; i &lt; clickBoxs.length; i++){ clickBoxs[i].onclick = function(){ console.log(i) } } 我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。 function iteratorFactory(i){ var onclick = function(e){ console.log(i) } return onclick; } var clickBoxs = document.querySelectorAll(&apos;.clickBox&apos;) for (var i = 0; i &lt; clickBoxs.length; i++){ clickBoxs[i].onclick = iteratorFactory(i) } const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。 const PI = Math.PI PI = 23 //Module build failed: SyntaxError: /es6/app.js: &quot;PI&quot; is read-only 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug： const monent = require(&apos;moment&apos;) #class, extends, super 这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？ 有了ES6我们不再烦恼！ ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 class Animal { constructor(){ this.type = &apos;animal&apos; } says(say){ console.log(this.type + &apos; says &apos; + say) } } let animal = new Animal() animal.says(&apos;hello&apos;) //animal says hello class Cat extends Animal { constructor(){ super() this.type = &apos;cat&apos; } } let cat = new Cat() cat.says(&apos;hello&apos;) //cat says hello 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 P.S 如果你写react的话，就会发现以上三个东西在最新版React中出现得很多。创建的每个component都是一个继承React.Component的类。详见react文档 #arrow function 这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多: function(i){ return i + 1; } //ES5 (i) =&gt; i + 1 //ES6 简直是简单的不像话对吧…如果方程比较复杂，则需要用{}把代码包起来： function(x, y) { x++; y--; return x + y; } (x, y) =&gt; {x++; y--; return x+y} 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如： class Animal { constructor(){ this.type = &apos;animal&apos; } says(say){ setTimeout(function(){ console.log(this.type + &apos; says &apos; + say) }, 1000) } } var animal = new Animal() animal.says(&apos;hi&apos;) //undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种： 第一种是将this传给self,再用self来指代this says(say){ var self = this; setTimeout(function(){ console.log(self.type + &apos; says &apos; + say) }, 1000) 第二种方法是用bind(this),即 says(say){ setTimeout(function(){ console.log(this.type + &apos; says &apos; + say) }.bind(this), 1000) 但现在我们有了箭头函数，就不需要这么麻烦了： class Animal { constructor(){ this.type = &apos;animal&apos; } says(say){ setTimeout( () =&gt; { console.log(this.type + &apos; says &apos; + say) }, 1000) } } var animal = new Animal() animal.says(&apos;hi&apos;) //animal says hi 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 #template string 这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。 大家可以先看下面一段代码： $(&quot;#result&quot;).append( &quot;There are &lt;b&gt;&quot; + basket.count + &quot;&lt;/b&gt; &quot; + &quot;items in your basket, &quot; + &quot;&lt;em&gt;&quot; + basket.onSale + &quot;&lt;/em&gt; are on sale!&quot; ); 我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串“后，我们可以直接这么来写： $(&quot;#result&quot;).append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale! `); 用反引号（\\）来标识起始，用${}`来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！ React Router从第1.0.3版开始也使用ES6语法了，比如这个例子： &lt;Link to={`/taco/${taco.name}`}&gt;{taco.name}&lt;/Link&gt; #destructuring ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 看下面的例子： let cat = &apos;ken&apos; let dog = &apos;lili&apos; let zoo = {cat: cat, dog: dog} console.log(zoo) //Object {cat: &quot;ken&quot;, dog: &quot;lili&quot;} 用ES6完全可以像下面这么写： let cat = &apos;ken&apos; let dog = &apos;lili&apos; let zoo = {cat, dog} console.log(zoo) //Object {cat: &quot;ken&quot;, dog: &quot;lili&quot;} 反过来可以这么写： let dog = {type: &apos;animal&apos;, many: 2} let { type, many} = dog console.log(type, many) //animal 2 #default, rest default很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || ‘cat’ 来指定默认值。 function animal(type){ type = type || &apos;cat&apos; console.log(type) } animal() 如果用ES6我们而已直接这么写： function animal(type = &apos;cat&apos;){ console.log(type) } animal() 最后一个rest语法也很简单，直接看例子： function animals(...types){ console.log(types) } animals(&apos;cat&apos;, &apos;dog&apos;, &apos;fish&apos;) //[&quot;cat&quot;, &quot;dog&quot;, &quot;fish&quot;] 而如果不用ES6的话，我们则得使用ES5的arguments。 #import export 这两个家伙对应的就是es6自己的module功能。 我们之前写的Javascript一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。 这有可能导致两个问题： 1.一方面js代码变得很臃肿，难以维护 2.另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。 而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。上面的设计思想看不懂也没关系，咱先学会怎么用，等以后用多了、熟练了再去研究它背后的设计思想也不迟！好，那我们就上代码… #传统的写法 首先我们回顾下require.js的写法。假设我们有两个js文件: index.js和content.js,现在我们想要在index.js中使用content.js返回的结果，我们要怎么做呢？ 首先定义： //content.js define(&apos;content.js&apos;, function(){ return &apos;A cat&apos;; }) 然后require： //index.js require([&apos;./content.js&apos;], function(animal){ console.log(animal); //A cat }) 那CommonJS是怎么写的呢？ //index.js var animal = require(&apos;./content.js&apos;) //content.js module.exports = &apos;A cat&apos; #ES6的写法 //index.js import animal from &apos;./content&apos; //content.js export default &apos;A cat&apos; 以上我把三者都列出来了，妈妈再也不用担心我写混淆了… #ES6 module的其他高级用法 //content.js export default &apos;A cat&apos; export function say(){ return &apos;Hello!&apos; } export const type = &apos;dog&apos; 上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类） //index.js import { say, type } from &apos;./content&apos; let says = say() console.log(`The ${type} says ${says}`) //The dog says Hello 这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。 如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。 //index.js import animal, { say, type } from &apos;./content&apos; let says = say() console.log(`The ${type} says ${says} to ${animal}`) //The dog says Hello to A cat #修改变量名 此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。 //index.js import animal, { say, type as animalType } from &apos;./content&apos; let says = say() console.log(`The ${animalType} says ${says} to ${animal}`) //The dog says Hello to A cat #模块的整体加载 除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 //index.js import animal, * as content from &apos;./content&apos; let says = content.say() console.log(`The ${content.type} says ${says} to ${animal}`) //The dog says Hello to A cat 通常星号*结合as一起使用比较合适。 #终极秘籍 考虑下面的场景：上面的content.js一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到type这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量： import { type } from &apos;./content&apos; 由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。 ES6帮我们实现了！ 不过，目前无论是webpack还是browserify都还不支持这一功能… 如果你现在就想实现这一功能的话，可以尝试使用rollup.js 他们把这个功能叫做Tree-shaking，哈哈哈，意思就是打包前让整个文档树抖一抖，把那些并未被依赖或使用的东西统统抖落下去。。。 看看他们官方的解释吧： Normally if you require a module, you import the whole thing. ES2015 lets you just import the bits you need, without mucking around with custom builds. It&apos;s a revolution in how we use libraries in JavaScript, and it&apos;s happening right now. #总结 以上就是ES6最常用的一些语法，可以说这20%的语法，在ES6的日常使用中占了80%…","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Node+React+Webpack+es6+less的环境配置","date":"2016-12-16T10:40:16.000Z","path":"2016/12/16/React/","text":"#React Demo React环境配置：Node+React+Webpack+es6+Less （清单），案例地址：https://github.com/betrs/ReactDemo.git #安装依赖： 命令中 –save-dev 含义是安装时顺便把配置信息写入到package.json文件中 1.生成一个 package.json文件 ： //使用命令： npm init //（一路默认即可） 2.安装 react 和 react-dom 依赖： //使用命令： npm install react react-dom --save-dev 3.安装 webpack 和 webpack-dev-server 依赖： //使用命令： npm install webpack webpack-dev-server --save-dev 4.安装 babel 依赖： //使用命令： npm install babel-loader babel-core babel-preset-react babel-preset-es2015 --save-dev 5.安装 less css 处理样式依赖： //使用命令： npm install less-loader css-loader style-loader --save-dev 6.安装 url-loader 处理资源依赖： //使用命令： npm install url-loader --save-dev #最终目录结构： --React |--node_modules（程序所有依赖） |--components（组件目录） |--wujia（组件wujia） |--images（图片夹子） |--index.jsx |--index.less |--input（组件input） |--images（图片夹子） |-- js.jpg |--input.jsx |--input.less |--blog（组件blog） |--images（图片夹子） |--index.jsx |--index.less |--index.js（入口文件） |--build（输出目录） |--index.html |--bundle.js (输出文件，由webpack打包后生成的) |--package.json |--webpack.config.js #Webpack 配置文件 webpack.config.js 的编写，代码如下（该文件需手动创建取名 webpack.config.js ）： var path = require(&apos;path&apos;); var webpack = require(&apos;webpack&apos;); var ROOT_PATH = path.resolve(__dirname); var APP_PATH = path.resolve(__dirname, &apos;./components/index.js&apos;); var BUILD_PATH = path.resolve(__dirname, &apos;./build&apos;); module.exports = { entry: APP_PATH, //入口文件路径 output: { path: BUILD_PATH, //输出打包后的文件路径并生成 bundle.js文件 filename: &apos;bundle.js&apos; }, module: { loaders: [{ test: /\\.css$/, //正则匹配.css后缀文件，并做相关处理 loader: &apos;style!css&apos; }, { test: /\\.less$/, //正则匹配.less后缀文件，并做相关处理 loader: &apos;style!css!less&apos; }, { test: /\\.(png|jpg)$/, //正则匹配.png或者jpg后缀文件，并做相关处理 loader: &apos;url?limit=50000&apos; }, { test: /\\.(jsx|js)?$/, //正则匹配.jsx或js后缀文件，并做相关处理 loaders: [&apos;babel-loader?presets[]=es2015,presets[]=react&apos;] }] }, entry: [ //自动更新入口配置 &apos;webpack/hot/dev-server&apos;, &apos;webpack-dev-server/client?http://localhost:3000&apos;, APP_PATH ] } #package.json 配置文件 的编写，代码如下： { &quot;name&quot;: &quot;reactdemo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;this is my first react case.&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --port 3000 --devtool eval --progress --colors --hot --content-base build&quot;, &quot;build&quot;: &quot;webpack&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;jasn&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.20.0&quot;, &quot;babel-loader&quot;: &quot;^6.2.10&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.18.0&quot;, &quot;babel-preset-react&quot;: &quot;^6.16.0&quot;, &quot;react&quot;: &quot;^15.4.1&quot;, &quot;react-dom&quot;: &quot;^15.4.1&quot;, &quot;webpack&quot;: &quot;^1.14.0&quot;, &quot;webpack-dev-server&quot;: &quot;^1.16.2&quot; } } #根据目录所示，我们需要创建两个组件，代码分别如下： 1.wujia组件代码： &quot;use strict&quot;; //开启严格模式 import React from &apos;react&apos;; //导入react依赖 import ReactDOM from &quot;react-dom&quot;; //导入react-dom依赖 /** * 创建一个组件，取名 Wujia * export default 把创建的组件 Wujia 暴露出去 * extends React.Component 让组件继承Component所有属性与方法 **/ export default class Wujia extends React.Component{ render(){ return &lt;a className={this.props.color} href={this.props.src} title={this.props.mes}&gt;{this.props.title}&lt;/a&gt; }; }; 组件Wujia编写的less样式 : @color:blue; .hello{ color:@color; text-decoration: none; &amp;:hover{ text-decoration:underline; } } 2.blog组件代码： &quot;use strict&quot;; //开启严格模式 import React from &quot;react&quot;; //导入react依赖 import ReactDOM from &quot;react-dom&quot;; //导入react-dom依赖 /** * 创建一个组件，取名 Blog * export default 把创建的组件 Blog 暴露出去 * extends React.Component 让组件继承Component所有属性与方法 **/ export default class Blog extends React.Component { render(){ return &lt;a className={this.props.color} href={this.props.src} title={this.props.mes}&gt;{this.props.name}&lt;/a&gt; }; }; 组件blog编写的less样式 : @color:red; .react{ color:@color; text-decoration: none; &amp;:hover{ text-decoration:underline; } } 3.input组件代码： &quot;use strict&quot;; //开启严格模式 import React from &quot;react&quot;; //导入react依赖 import ReactDOM from &quot;react-dom&quot;; //导入react-dom依赖 /** * 创建一个组件，取名 Input * export default 把创建的组件 Input 暴露出去 * extends React.Component 让组件继承Component所有属性与方法 **/ export default class Input extends React.Component{ //初始化状态 constructor(props,context){ super(props,context); this.state = { value: this.props.value }; }; //事件函数（输入框改变触发） changeHandle(ev){ //设置状态 this.setState({ value: ev.target.value }); }; render(){ return ( &lt;div&gt; &lt;input className={this.props.class1} type=&quot;text&quot; value={this.state.value} onChange={this.changeHandle.bind(this)}/&gt; &lt;p className={this.props.class2}&gt;{this.state.value}&lt;/p&gt; &lt;img className={this.props.class3} src={this.props.src}/&gt; &lt;/div&gt; ); }; }; 组件input编写的less样式 : .input{width: 180px;height: 30px;line-height: 30px;padding:0 10px;border:1px solid #ddd;font-size:14px;color:#333;} .tishi{display: inline-block;font-size:16px;color:green;margin-left:20px;} .img{display:block;margin-top:20px;} #创建页面 index.html （ build目录下 ）来使用前面创建的两个组件，代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;wrap&quot;&gt;&lt;div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; #使用webpack打包 Webpack 是一个前端模块加载兼打包工具，可以对 JS、CSS 和 图片 等都作为模块来使用和处理。对不同类型的需要编译的文件，需要使用相应的加载器（比如用 babel 转译 ES6）。 另外，由于 Webpack 需要一个入口文件来进行分析和处理，需要先将 React 组件引入到一个主文件。 从前文的目录结构可以看出， components/index.js 就是这个主文件，它的代码如下： &quot;use strict&quot;; import React from &quot;react&quot;; //导入react依赖 import ReactDOM from &quot;react-dom&quot;; //导入react-dom依赖 import Wujia from &quot;./wujia/index.jsx&quot;;//导入wujia组件 import Blog from &quot;./blog/index.jsx&quot;;//导入blog组件 import Input from &quot;./input/input.jsx&quot;;//导入input组件 import url from &quot;./input/images/js.jpg&quot;;//导入图片资源 import &quot;./wujia/index.less&quot;;//导入wujia组件样式 import &quot;./blog/index.less&quot;;//导入blog组件样式 import &quot;./input/input.less&quot;;//导入input组件样式 //创建一个input组件数据对象 const obj2 = { value:&quot;吴佳&quot;, class1:&quot;input&quot;, class2:&quot;tishi&quot;, class3:&quot;img&quot;, src:url }; //开始渲染DOM结构 ReactDOM.render( ( &lt;div&gt; &lt;h1&gt; &lt;Wujia color=&quot;hello&quot; title=&quot;吴佳&quot; src=&quot;https://www.github.com/betrs&quot; mes=&quot;吴佳Github&quot;/&gt; &lt;Blog color=&quot;react&quot; name=&quot;博客&quot; src=&quot;http://www.wujiabk.com&quot; mes=&quot;吴佳博客&quot;/&gt; &lt;/h1&gt; &lt;Input {...obj2}/&gt; &lt;/div&gt; ), document.querySelector(&quot;.wrap&quot;) ); 最后，需要将编译打包后的文件 bundle.js 引入到 index.html 中： &lt;body&gt; ... &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; #构建和启动 #构建 前面的开发完成后，需要执行 webpack.config.js 中的构建任务，生成 bundle.js ，可以看到在 package.json 中我们在scripts内配置了”build”：”webpack”： &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot; } 然后执行命令 npm run build 完成构建，此时打开 index.html ，即可看到效果。 #启动服务器 但这种方式显得略 low，一是它是双击以文件的形式打开 HTML 页面，二是每次有更改都要手动执行 npm run build 重新打包。 一种更好的方式是启动一个静态资源服务器，监听文件内容修改并自动打包。在这里用的是前面安装好的 webpack-dev-server ，在 package.json 配置中可以看到如下代码： &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --port 3000 --devtool eval --progress --colors --hot --content-base build&quot; } 简单解释一下 dev 中各个参数的含义： webpack-dev-server 在 localhost:3000（不设置端口默认是8080） 建立一个 Web 服务器； –devtool eval 映射编译好的源码，用于调试； –progress 显示代码打包进度； –colors 表示在命令行中显示颜色； –content-base 来指定 server 启动后的内容目录。 执行命令 npm run dev 启动 server，此时打开浏览器输入 http://localhost:3000 ，即可看到效果。修改一下 Hello 或者 World 组件中的内容，刷新页面，你会发现浏览器中内容也相应改变了。 #自动刷新 前面实现了对文件修改的监听和自动打包，但浏览器还需要手动刷新。其实可以在 Webpack 的配置文件中增加一个入口点，实现自动刷新。 在webpack.config.js中我们可以看到如下代码： ··· entry: [ &apos;webpack/hot/dev-server&apos;, &apos;webpack-dev-server/client?http://localhost:3000&apos;, APP_PATH ], ··· 这样，应用在修改后，浏览器就会实时监听进行自动刷新了。 #说明：如果设置了自动更新入口，我们需要在package.json配置文件中scripts中设置dev，代码如下： ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --port 3000 --devtool eval --progress --colors --hot --content-base build&quot;, &quot;build&quot;: &quot;webpack&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; } ... 最后执行命令： npm run dev //就可以跑起来了，然后可以试试是不是自动更新。 如果你是直接从github拉下来的demo，首先cd到ReactDemo目录,然后执行：npm install （自动安装依赖），然后输入上方npm run dev 就行了。","tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"工作常用的Git命令","date":"2016-12-06T05:31:11.000Z","path":"2016/12/06/gitCommand/","text":"我每天使用 Git ，但是很多命令记不住。一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 #一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] #二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; #三、增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] #四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... #五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] #六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] #七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog #八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all #九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop #十、其他 # 生成一个可供发布的压缩包 $ git archive","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"ES6 你可能不知道的事 - 基础篇","date":"2016-10-21T01:12:07.000Z","path":"2016/10/21/es6Basics/","text":"#序 ES6，或许应该叫 ES2015（2015 年 6 月正式发布），对于大多数前端同学都不陌生。 首先这篇文章不是工具书，不会去过多谈概念，而是想聊聊关于每个特性 你可能不知道的事，希望能为各位同学 正确使用 ES6，提供一些指导。 对于 ES6，有些同学已经在项目中有过深入使用了，有些则刚刚开始认识他，但不论你是属于哪一类，相信这篇文章都有适合你的部分。针对文章中的问题或不同意见，欢迎随时拍砖、指正。 #正文 Let + Const 这个大概是开始了解 ES6 后，我们第一个感觉自己完全明白并兴致勃勃的开始使用的特性。 以如下方式使用的同学请举下手？ 1 // 定义常量 2 const REG_GET_INPUT = /^\\d{1,3}$/; 3 4 // 定义配置项 5 let config = { 6 isDev : false, 7 pubDir: &apos;./admin/&apos; 8 } 9 10 // 引入 gulp 11 let gulp = require(&apos;gulp&apos;); 12 13 // 引入gulp相关插件 14 let concat = require(&apos;gulp-concat&apos;); 15 let uglify = require(&apos;gulp-uglify&apos;); 16 let cssnano = require(&apos;gulp-cssnano&apos;); 很多人看完概念之后，第一印象都是：“const 是表示不可变的值，而 let 则是用来替换原来的 var 的。” 所以就会出现上面代码中的样子；一段代码中出现大量的 let，只有部分常量用 const 去做定义，这样的使用方式是错误的。 你可能不知道的事 const 的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性。 所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以const做定义。反之就 let 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。 猜想：就执行效率而言，const 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。 所以上面代码中，所有使用 let 的部分，其实都应该是用 const 的。 Template Strings（字符串模板） 字符串模板是我刚接触ES6时最喜欢的特性之一，他语法简洁，语义明确，而且很好的解决了之前字符串拼接麻烦的问题。 因为他并不是 “必须” 的，而且原有的字符串拼接思维根深蒂固，导致我们很容易忽视掉他。 使用实例 我们先来看看他的一般使用场景： 1 const start = &apos;hi all&apos;; 2 3 const getName = () =&gt; { 4 return &apos;jelly&apos;; 5 }; 6 7 const conf = { 8 fav: &apos;Coding&apos; 9 }; 10 11 // 模板 12 const msg = `${start}, my name is ${getName()}, ${conf.fav} is my favourite`; 你可能不知道的事 1 // 1. 与引号混用 2 const wantToSay = `I&apos;m a &quot;tbfed&quot;`; 3 4 // 2. 支持多行文本 5 const slogan = 6 &apos; 7 I have a dream today! 8 &apos;; 9 10 // 比较适合写HTML 11 const resultTpl = 12 &apos; 13 &lt;section&gt; 14 &lt;div&gt;...&lt;/div&gt; 15 &lt;/section&gt; 16 &apos;; 17 #Enhanced Object Literals（增强的对象字面量） 增强的对象字面量是 ES6 中的升华功能，他设计了很多简写，这些简写不但保留了明确的语义，还减少了我们多余的代码量。 当他的使用成为一个习惯时，我们会看到自己代码变得更为优雅。 你可能不知道的事 1 const _bookNum = 4; 2 3 const basicConfig = { 4 level: 5 5 } 6 7 const config = { 8 // 直接指定原型对象 9 __proto__: basicConfig, 10 11 // 属性简写 12 _bookNum, 13 14 // 方法简写 15 getBookNum() { 16 return this.bookNum; 17 } 18 } #Arrows and Lexical This（箭头函数） 箭头函数是ES6中的一个新的语法特性，他的用法简单，形态优雅，备受人们青睐。 大多数同学初识这个特性时，更多的仅仅用它作为函数定义的简写，这其实就有些屈才了。 1 // 未使用箭头函数的写法 2 { 3 ... 4 5 addOptions: function (options) { 6 7 var self = this; 8 9 options.forEach(function(name, opts){ 10 11 self[name] = self.addChild(name, opts); 12 13 }); 14 15 } 16 } 17 18 // 使用箭头函数后的写法 19 { 20 ... 21 22 addOptions: function (options) { 23 24 options.forEach((name, opts) =&gt; { 25 26 this[name] = this.addChild(name, opts); 27 28 }); 29 30 } 31 } 可以注意到上下两段代码的区别。 在未使用箭头函数前，我们在过程函数中使用父级 this，需要将其显式缓存到另一个中间变量中，因为过程函数有独立的 this 变量，会覆盖父级；使用箭头函数后，不但简写了一个过程函数（ forEach 的参数），还省略掉了 this 的中间变量的定义。 原因：箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。 插播：原来我们定义这个中间变量还有一个有趣的现象，就是明明千奇百怪，例如 self, that, me, _that, _me, Self…，快站出来说说你用过哪个，还是哪几个~ 当然，从这块我们也可以看出，箭头函数是无法替代全部 function 的使用场景的，例如我们需要有独立 this 的函数。 你可能不知道的事 箭头函数不但没有独立 this，他也没有独立的 arguments，所以如果需要取不定参的时候，要么使用 function，要么用 ES6 的另一个新特性 rest（具体在 rest 中会有详解）。 箭头函数语法很灵活，在只有一个参数或者只有一句表达式做方法体时，可以省略相应括号。 1 // 完整写法 2 const getOptions = (name, key) =&gt; { 3 ... 4 } 5 6 // 省略参数括号 7 const getOptions = key =&gt; { 8 ... 9 } 10 11 // 省略参数和方法体括号 12 const getOptions = key =&gt; console.log(key); 13 14 // 无参数或方法体，括号不能省略 15 const noop = () =&gt; {}; 16 有个简单小栗子，这一灵活的语法在写连续的Promise链式调用时，可以使代码更加优雅 1 gitPromise 2 .then(() =&gt; git.add()) 3 .then(() =&gt; git.commit()) 4 .then(() =&gt; git.log()) 5 .then((msg) =&gt; { 6 ... 7 }) 8 .then(() =&gt; git.push()) 9 .catch((err) =&gt; { 10 utils.error(err); 11 }); #Destructuring（解构） 解构这个特性可以简单解读为分别定义，用于一次定义多个变量，常常用于分解方法返回对象为多个变量，分别使用。 使用过ES6的同学应该或多或少接触过这个特性，但是你可能不知道它如下几个用法： 你可能不知道的事 1 const bookSet = [&apos;UED&apos;, &apos;TB fed&apos;, &apos;Not find&apos;]; 2 const bookCollection = () =&gt; { 3 return {book1: &apos;UED&apos;, book2: &apos;TB fed&apos;}; 4 }; 5 6 // 1. 解构也可以设置默认值 7 const {book1, book3 = &apos;Not find&apos;} = bookCollection(); 8 9 // 2. 解构数组时候是可以跳过其中某几项的 10 const [book1,,book3] = bookSet; // book1 = &apos;UED&apos;, book3 = &apos;Not find&apos; 11 12 // 3. 解构可以取到指定对象的任何属性，包括它包含的方法 13 const {length: setLength} = bookSet; // setLength = 3 #Rest + Spread Rest 和 Spread 主要是应用 … 运算符，完成值的聚合和分解。 你可能不知道的事 1 // 1. rest 得到的是一个真正的数组而不是一个伪数组 2 const getOptions = function(...args){ 3 console.log(args.join); // function 4 }; 5 6 // 2. rest 可以配合箭头函数使用，达到取得所有参数的目的 7 const getOptions = (...args) =&gt; { 8 console.log(args); // array 9 }; 10 11 // 3. spread 可以用于解构时，聚合所得的值 12 const [opt1, ...opts] = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;]; 13 14 // 4. spread 可以用于数组定义 15 const opts = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;]; 16 const config = [&apos;other&apos;, ...opts]; #Classes ES6 中实现的一个语法糖，用于简化基于原型集成实现类定义的场景。 虽然有很多人不太喜欢这个特性，认为它作为一个简单增强扩展，并没有其他语言 class 应有的特点。 但是就我自己观点来看，还是感觉这样一种写法确实比原有的原型继承的写法语义更清晰、明确，而且语法更简单。 同样，可能有些用法是你之前容易忽略掉的，在此做个补充。 你可能不知道的事 1 // 1. 静态变量 2 // ES6 的类定义实现了静态方法的定义，但静态变量呢？ 3 // 可以用如下方式实现: 4 class TbFedMembers{ 5 static get HuaChen(){ 6 return &apos;jelly&apos;; 7 } 8 } 9 TbFedMembers.HuaChen; // &quot;化辰&quot; 10 11 // 2. 私有属性（私有属性有多种实现方式，只谈及其中一种） 12 // 闭包 13 const TbFedMembers = (() =&gt; { 14 const HuaChen = &apos;jelly&apos;; 15 16 return class{ 17 getOneMemberName(){ 18 return HuaChen; 19 } 20 }; 21 })(); #Promises Promise 不只是一个对象、一个语法，他更是一种异步编程方式的变化 相信使用过 ES6 的同学都已经开始尝试了 Promise，甚至在不支持ES6的时候，已经开始使用一些基于 Promise 思想的开源框架。 那么我们之前用 Promise 究竟用的对么？有什么需要注意的点呢？ 你可能不知道的事 1 // 1. 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用 2 // Promise.all 3 Promise 4 .all([jsBuildPromise, cssBuildPromise]) 5 .then(() =&gt; { 6 ... 7 }); 8 9 // chain 10 jsBuildPromise 11 .then(() =&gt; cssBuildPromise) 12 .then(() =&gt; { 13 ... 14 }); 15 16 17 // 2. Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行 18 gitPromise 19 .then(() =&gt; git.add()) // 正确，箭头函数简写 20 .then(() =&gt; { 21 git.commit(); // 错误，函数返回 undefined，会立即执行下一过程 22 }) 23 .then(() =&gt; { 24 return git.log(); // 正确 25 }); 26 27 28 // 3. Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行 29 new Promise(() =&gt; { 30 f; // not define error ! 31 }) 32 .catch((err) =&gt; { 33 console.log(err) // show &apos;f is not define&apos; 34 }); 35 console.log(&apos;error test&apos;); // 此行可以被正常执行 #结语 基础篇主要是讲了我们最常用的一些特性，后续如果大家感兴趣，还可以再来个 “进阶篇”，最后，希望文章中的部分内容可以对大家理解和使用 ES6 有所帮助。 转自：http://taobaofed.org/blog/2016/07/22/es6-basics/","tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Js调试工具，万能的Console","date":"2016-10-14T10:01:28.000Z","path":"2016/10/14/console/","text":"#一 、什么是 ConsoleConsole 是用于显示 JS和 DOM 对象信息的单独窗口。并且向 JS 中注入1个 console 对象，使用该对象 可以输出信息到 Console 窗口中。 #二、什么浏览器支持 Console很多人可能都知道 Chrome 和 FireFox(FireBug)中都支持 Console。而其他浏览器都支 持不好。比如 IE8 自带的开发工具虽然支持 Console，但功能比较单调，显示对象的时候都是显示 [Object,Object]，而且不能点击查看对象里面的属性。IE6、IE7 虽然可以安装 Developer Toolbar，但也 不支持 console。Safari、Opera 都支持 Console，但使用上都没有 FireBug和 Chrome 的方便。 现在firebug推出了firebuglite工具，可以让所有浏览器都支持Console功能，而且使用上和FireBug 几乎一样。 #三、为什么不直接使用 alert 或自己写的 log使用 alert 不是一样可以显示信息，调试程序吗？alert 弹出窗口会中断程序， 如果要在循环中显示信息，手点击关闭窗口都累死。而且 alert 显示对象永远显示为[object ]。 自己写的 log 虽然可以显示一些 object 信息，但很多功能支持都没有 console 好，看完后面 console 的介绍就知道了。 #四、Console.log(object[, object, …])Console.log 是最简单输出信息到 console 窗口的方法，支持多个参数，该方法会把 这些参数组合在一起显示，e.g： log 方法第一个参数支持类似 C 语言 printf 字符串替换模式，Log 支持下面几种替换模式： %s 代替字符串 %d 代替整数 %f 代替浮点值 %o 代替 Object #五、console.debug，info，warn，error这4种方法与log方法使用一模一样，只是显示的图标和文字颜色不一样. #六、console.assert(expression[, object, …])assert 方法类似于单元测试中的断言，当 expression 表达式为 false 的时候，输出后面的信息,e.g： 注：assert 方法在 firebuglite 不支持，Chrome 和 FireBug 支持 #七、console.clear()该方法清空 console 中的所有信息 (Chrome中不支持) #八、console.dirxml(node)把html元素的html代码打印出来,等同于log. #九、console.trace()trace 方法可以查看当前函数的调用堆栈信息，即当前函数是如何调用的，e.g: #十、console.group(object[, object, …]), groupCollapsed, groupEnd这3个函数用于把log等输出的信息进行分组，方便阅读查看。groupCollapsed 方法与 group 方法一样，只是显示的分组默认是折叠的. #十一、console.time(name)/console.timeEnd(name)我们经常需要测试 js 函数的执行时间，可能我们自己写代码在第1 条语句和 最后 1 条语句取当前时间相减。这组函数其实就实现了这样的功能，time(name)根据 name 创建 1 个新 的计时器。timeEnd(name)停止给定name 的计时器，并显示时间。 #十二、console.profile(name)/console.profileEnd()这组方法用于打开浏览器的分析器，用于分析这组函数之间的 js 执行情况， 注：firebuglite 不支持 profile 功能，Chrome 支持 profile，但分析的内容不详。 #十三、console.count([title])count 方法用于统计当前代码被执行过多少次，title 参数可以在次数前面输出额外的标题以帮助阅读。e.g: #十四、console.table(data)table 方法把data 对象用表格的方式显示出来，这在显示数组或者格式一样的JSON 对象的时候非常有用。注：table 只支持 FireBug，而且是在 firebug1.6+版本后才有。 总结： Console 是帮助我们学习和调试 JS的 1 个非常好工具，如果你以前没用过，哪现在就开始用它吧。你会发现它能帮你省很多开发时间的。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"js闭包详解","date":"2016-10-13T07:50:38.000Z","path":"2016/10/13/detailedClosure/","text":"闭包有三个特性：1.函数嵌套函数2.函数内部可以引用外部的参数和变量3.参数和变量不会被垃圾回收机制回收闭包的定义及其优缺点 闭包 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量 使用闭包有一个优点，也是它的缺点，就是可以把局部变量驻留在内存中，可以避免使用全局变量。全局变量在每个模块都可调用，这势必将是灾难性的。（所以推荐使用私有的，封装的局部变量。） 一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！ 嵌套函数的闭包 function aaa() { var a = 1; return function(){ alert(a++) }; } var fun = aaa(); fun();// 1 执行后 a++，，然后a还在~ fun();// 2 fun = null;//a被回收！！ 闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗。 javascript的垃圾回收原理 （1）、在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收；（2）、如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。 使用闭包的好处 那么使用闭包有什么好处呢？使用闭包的好处是： 1.希望一个变量长期驻扎在内存中2.避免全局变量的污染3.私有成员的存在 #一、全局变量的累加 var a = 1; function abc(){ a++; alert(a); } abc(); //2 abc(); //3 #二、局部变量 function abc(){ var a = 1; a++; alert(a); } abc(); //2 abc(); //2 那么怎么才能做到变量a既是局部变量又可以累加呢？ #三、局部变量的累加 function outer(){ var x=10; return function(){ //函数嵌套函数 x++; alert(x); } } var y = outer(); //外部函数赋给变量y; y(); //y函数调用一次，结果为11，相当于outer()()； y(); //y函数调用第二次，结果为12，实现了累加 函数声明与函数表达式 在js中我们可以通过关键字function来声明一个函数： function abc(){ alert(123); } abc(); 我们也可以通过一个”()”来将这个声明变成一个表达式： (function (){ alert(123); })(); //然后通过()直接调用前面的表达式即可，因此函数可以不必写名字； #四、模块化代码，减少全局变量的污染 var abc = (function(){ //abc为外部匿名函数的返回值 var a = 1; return function(){ a++; alert(a); } })(); abc(); //2 调用一次abc函数，其实是调用里面内部函数的返回值 abc(); //3 #五、私有成员的存在 var aaa = (function(){ var a = 1; function bbb(){ a++; alert(a); } function ccc(){ a++; alert(a); } return { b:bbb,//json结构 c:ccc } })(); aaa.b(); //2 aaa.c(); //3 #六.使用匿名函数实现累加使用匿名函数实现局部变量驻留内存中，从而实现累加 function box(){ var age = 100; return function(){ //匿名函数 age++; return age; }; }; var b = box(); alert(b()); alert(b()); //即alert(box()())； alert(b()); alert(b); function () { age++; return age; } b = null； //解除引用，等待垃圾回收 过度使用闭包会导致性能的下降。函数里放匿名函数，则产生了闭包 #七、在循环中直接找到对应元素的索引 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var aLi = document.getElementsByTagName(&apos;li&apos;); for (var i=0;i&lt;aLi.length;i++){ aLi[i].onclick = function(){ //当点击时for循环已经结束 alert(i); }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;456&lt;/li&gt; &lt;li&gt;789&lt;/li&gt; &lt;li&gt;010&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; #八、使用闭包改写上面代码 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var aLi = document.getElementsByTagName(&apos;li&apos;); for (var i=0;i&lt;aLi.length;i++){ (function(i){ aLi[i].onclick = function(){ alert(i); }; })(i); } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;456&lt;/li&gt; &lt;li&gt;789&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; #九.内存泄露问题 由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄露问题，也就是无法销毁驻留在内存中的元素 function closure(){ var oDiv = document.getElementById(&apos;oDiv&apos;);//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () { alert(&apos;oDiv.innerHTML&apos;);//这里用oDiv导致内存泄露 }; } closure(); //最后应将oDiv解除引用来避免内存泄露 function closure(){ var oDiv = document.getElementById(&apos;oDiv&apos;); var test = oDiv.innerHTML; oDiv.onclick = function () { alert(test); }; oDiv = null; } #十.思考题 如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。 var name = &quot;trigkit4&quot;; var segmentFault = { name : &quot;My SF&quot;, getNameFunc : function(){ return function(){ return this.name; }; } }; //alert(segmentFault.getNameFunc()()); //弹出trigkit4","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]