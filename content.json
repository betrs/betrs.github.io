{"meta":{"title":"吴佳（Jasn）博客","subtitle":"一名JavaScript狂热分子 ，推崇开源精神 ，为开源事业添砖加瓦！","description":"关注前端领域，JavaScript狂热分子。推崇开源精神，为开源事业添砖加瓦 - 吴佳（Jasn）博客","author":"吴佳（Jasn）","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"编写“纯粹”的JavaScript代码","slug":"pureJavasript","date":"2017-01-05T01:45:43.000Z","updated":"2017-01-05T01:51:15.878Z","comments":true,"path":"2017/01/05/pureJavasript/","link":"","permalink":"http://yoursite.com/2017/01/05/pureJavasript/","excerpt":"一旦你网站或应用的代码量达到一定程度，它将不可避免的包含某种bug。这不是JavaScript特有的问题，而是一个几乎所有语言都有的通病 —— 虽然不是不可能，但是想要彻底清除程序中的所有bug还是非常难办到的。但是，这并不意味着我们不可以通过某些编码方式来预防bug的引入。 #纯函数与非纯函数 纯函数是指不依赖，修改其作用域之外变量的函数。这么说有点拗口，还是让我们看几个具体的例子吧。 以这个计算用户的鼠标是否在屏幕左侧的函数为例。当鼠标在屏幕左侧时向控制台输出true，反之输出false。在现实中你的函数很可能会比这个例子更复杂，执行更多的操作，此处只是为了演示说明问题： function mouseOnLeftSide(mouseX) { return mouseX &lt; window.innerWidth / 2; } document.onmousemove = function(e) { console.log(mouseOnLeftSide(e.pageX)); };","text":"一旦你网站或应用的代码量达到一定程度，它将不可避免的包含某种bug。这不是JavaScript特有的问题，而是一个几乎所有语言都有的通病 —— 虽然不是不可能，但是想要彻底清除程序中的所有bug还是非常难办到的。但是，这并不意味着我们不可以通过某些编码方式来预防bug的引入。 #纯函数与非纯函数 纯函数是指不依赖，修改其作用域之外变量的函数。这么说有点拗口，还是让我们看几个具体的例子吧。 以这个计算用户的鼠标是否在屏幕左侧的函数为例。当鼠标在屏幕左侧时向控制台输出true，反之输出false。在现实中你的函数很可能会比这个例子更复杂，执行更多的操作，此处只是为了演示说明问题： function mouseOnLeftSide(mouseX) { return mouseX &lt; window.innerWidth / 2; } document.onmousemove = function(e) { console.log(mouseOnLeftSide(e.pageX)); }; mouseOnLeftSide()接受一个X坐标并判断它是否小于屏幕宽度数值的一半。然而，mouseOnLeftSide()并不是一个纯函数。我们之所以这么说是因为在函数内部，它引用了一个没有被明确传入的变量： return mouseX &lt; window.innerWidth / 2; 这个函数被调用时传入了mouseX，但没有传入window.innerWidth。这意味着该函数访问了一个不是作为参数传入的变量，因此它不是纯函数。 #非纯函数的问题 你可能会问这有问题呢 —— 这段代码明明可以正常工作。假设有人向你报告了一个bug：当window的宽度小于500像素时该函数不能正常工作。你该如何验证该问题呢？你有两个选择： 你可以手工进行测试。打开浏览器，移动鼠标直到能复现问题。你可以编写一些单元测试(Rebecca Murphey的编写可测试的JavaScript代码是个不错的入门)，这不仅可以用于此次调查问题，还可以避免以后再出现相同的问题。 为了避免问题再次发生，我们决定选择第二种方案并编写测试代码。现在一个新问题出现了：如何正确的建立我们的测试呢？我们知道需要在window宽度小于500像素的情况下建立测试，但是该如何操作呢？该函数依赖于window.innerWidth，然而要确保window.innerWidth为某个确定值将是件痛苦的事情。 #纯函数的好处 ##方便测试 假设在考虑过如何测试的问题之后，我们这样编写代码： function mouseOnLeftSide(mouseX, windowWidth) { return mouseX &lt; windowWidth / 2; } document.onmousemove = function(e) { console.log(mouseOnLeftSide(e.pageX, window.innerWidth)); }; 关键的区别在于这次mouseOnLeftSide()函数接受2个参数：鼠标的X坐标和window的宽度。这意味现在mouseOnLeftSide()已经是一个纯函数了，它所需的所有数据都被明确传入了，不再需要访问函数外部的变量。 在功能方面，它和我们之前的例子完全一样。但在可维护性和可测试性两方面却得到了极大的改善。现在我们不再需要为了测试而对window.innerWidth动手脚，只需要给mouseOnLeftSide()传入合适的参数就可以了： mouseOnLeftSide(5, 499) // 确保window宽度小于500时可以正常工作 #自我注释 除了方便测试外，还有其它特点促使你应该在任何可能的时候使用纯函数。就其本质而言，纯函数是自我注释的。如果一个函数不会访问其作用域之外的变量，那么你就知道它能操作的数据就只能是传入的参数。考虑以下的函数定义： function mouseOnLeftSide(mouseX, windowWidth) 从定义可以看出该函数与两个参数打交道，如果参数被合理的命名，你还能看出它们是什么数据。我们都经历过阅读6个月之前编写的代码时的痛苦，因此能快速熟悉代码是一项很重要的能力。 #避免函数内的全局变量 JavaScript中全局变量的问题是有据可查的。在JavaScript中你可以很容易的创建全局变量，这些变量可以在所有函数中访问到。这也是一个导致bug的常见原因，因为程序中的任何部分都可能修改全局变量从而导致函数的行为出现异常。 纯函数的另一个特性是引用透明。这个复杂术语包含的含义很简单：给定相同的输入，输出结果始终是相同的。让我们回到mouseOnLeftSide函数，看看它的第一个版本： function mouseOnLeftSide(mouseX) { return mouseX &lt; window.innerWidth / 2; } 这个版本的函数不是引用透明的。如果我调用该函数5次，在这期间不断的改变window大小，那这5次调用的结果就会各不相同。这个例子可能看上去不太自然，但那种输入一致输出却不一致的函数实在是难以使用。由于它们的行为捉摸不定，要想预测它们就更难了。基于同样的原因，针对它们的测试也会很麻烦，因为你不能完全控制该函数依赖的数据。 另一方面，由于我们改进过的mouseOnLeftSide函数依赖的数据都来自输入并且没有访问外部数据，因此它是依赖透明的。 function mouseOnLeftSide(mouseX, windowWidth) { return mouseX &lt; windowWidth / 2; } 当你遵循了把所有依赖的数据都声明为参数的原则后，你的代码就自动获得了依赖透明的能力。通过这种编码方式你可以摆脱各类由副作用导致的bug以及意外的函数行为。如果你对数据有完全的控制，你就可以非常快速，轻松的复现，调试bug而不必费尽心思的调查可能导致问题的全局变量。 #选择把哪个函数变成纯函数 想要在所有场景中都使用纯函数是不现实的 —— 总有一些情况需要你跳出函数获取数据，这其中最常见的情景就是查询DOM以获取某个DOM元素。 这是JavaScript的一个实际情况并且你不得不这样做，你也不必为这种跳出函数获取数据的行为感到担心。相反的，你应该仔细考虑如何组织代码以便把非纯函数隔离开来。防止它们对你的代码造成广泛影响，并在任何合适的地方使用纯函数。 让我们看看以下的代码，它从DOM中获取一个元素并将该元素的背景色设置为红色： function changeElementToRed() { var foo = document.getElementById(&apos;foo&apos;); foo.style.backgroundColor = &quot;red&quot;; } changeElementToRed(); 这段代码有2个问题，都可以通过转变为纯函数来解决： 这个函数完全不能被重用。它和特定的DOM元素紧密的联系在一起。我们不能使用它修改其它的元素。由于是非纯函数，它很难被测试。要想测试它，我们不得不创建带有某个特定ID的元素。 考虑到以上2点，我会把它重写成以下的形式： function changeElementToRed(elem) { elem.style.backgroundColor = &quot;red&quot;; } function changeFooToRed() { var foo = document.getElementById(&apos;foo&apos;); changeElementToRed(foo); } changeFooToRed(); 我们修改changeElementToRed()函数以使它不再与任何特定的元素有关联。与此同时，我们把它变纯了，这就带来了我们之前讨论过的所有的优点。 需要注意的是，修改后的代码里还是有非纯函数代码，就是changeFooToRed()。这是不可避免的，但这里要说的是把一个函数改造成纯函数会增加它的可读性，可复用性以及可测试性。通过创建尽可能多的纯的，可复用的代码同时把不纯代码限制在最低程度你可以编写出更好的代码并在未来避免更多烦恼。 #总结 “纯函数”，“副作用”以及“引用透明”都是函数式编程语言中的术语，但这并不意味着我们不能把这些理念引用到JavaScript中。通过铭记这些原则，并明智地运用它们，你的代码可以变得更加可靠，自我注释同时更不容易出错。我建议你下次编写新代码甚至是查看现有代码时把这些概念铭记在心。要熟悉这些理念可能会需要一段时间，但是很快你就会发现自己在不知不觉中就应用它们了。你的小伙伴和未来的你都会感谢你自己的。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"前端模块化（CMD&AMD）","slug":"module","date":"2016-12-22T08:55:46.000Z","updated":"2016-12-22T09:01:49.569Z","comments":true,"path":"2016/12/22/module/","link":"","permalink":"http://yoursite.com/2016/12/22/module/","excerpt":"在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀 。 这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码 #模块 既然JavaScript不能handle如此大规模的代码，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要带概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接import对应的package即可 import java.util.ArrayList;","text":"在JavaScript发展初期就是为了实现简单的页面交互逻辑，寥寥数语即可；如今CPU、浏览器性能得到了极大的提升，很多页面逻辑迁移到了客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛应用，jQuery等前端库层出不穷，前端代码日益膨胀 。 这时候JavaScript作为嵌入式的脚本语言的定位动摇了，JavaScript却没有为组织代码提供任何明显帮助，甚至没有类的概念，更不用说模块（module）了，JavaScript极其简单的代码组织规范不足以驾驭如此庞大规模的代码 #模块 既然JavaScript不能handle如此大规模的代码，我们可以借鉴一下其它语言是怎么处理大规模程序设计的，在Java中有一个重要带概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，那么外部如果使用呢？直接import对应的package即可 import java.util.ArrayList; 遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，各行其是就都乱套了 规范形成的过程是痛苦的，前端的先驱在刀耕火种、茹毛饮血的阶段开始，发展到现在初具规模，简单了解一下这段不凡的历程 #函数封装 我们在讲函数的时候提到，函数一个功能就是实现特定逻辑的一组语句打包，而且JavaScript的作用域就是基于函数的，所以把函数作为模块化的第一步是很自然的事情，在一个文件里面编写几个相关函数就是最开始的模块了 function fn1(){ statement } function fn2(){ statement } 这样在需要的以后夹在函数所在文件，调用函数就可以了 这种做法的缺点很明显：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。 #对象 为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中 var myModule = { var1: 1, var2: 2, fn1: function(){ }, fn2: function(){ } } 这样我们在希望调用模块的时候引用对应文件，然后 myModule.fn2(); 这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系 看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员 myModel.var1 = 100; 这样就会产生意外的安全问题 #立即执行函数 可以通过立即执行函数，来达到隐藏细节的目的 var myModule = (function(){ var var1 = 1; var var2 = 2; function fn1(){ } function fn2(){ } return { fn1: fn1, fn2: fn2 }; })(); 这样在模块外部无法修改我们没有暴露出来的变量、函数 上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD #CommonJS 我们先从CommonJS谈起，因为在网页端没有模块化编程只是页面JavaScript逻辑复杂，但也可以工作下去，在服务器端却一定要有模块，所以虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来，CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。 #定义模块 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性 #模块输出： 模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象 #加载模块： 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象 #看个例子 //模块定义 myModel.js var name = &apos;Byron&apos;; function printName(){ console.log(name); } function printFullName(firstName){ console.log(firstName + name); } module.exports = { printName: printName, printFullName: printFullName } //加载模块 var nameModule = require(&apos;./myModel.js&apos;); nameModule.printName(); 不同的实现对require时的路径有不同要求，一般情况可以省略js拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块） #尴尬的浏览器 仔细看上面的代码，会发现require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。 这在服务器端实现很简单，也很自然，然而， 想在浏览器端实现问题却很多。浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script 标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。 解决思路之一是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。 另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧： #AMD AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范 由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出 #requireJS主要解决两个问题 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 #看一个使用requireJS的例子 // 定义模块 myModule.js define([&apos;dependency&apos;], function(){ var name = &apos;Byron&apos;; function printName(){ console.log(name); } return { printName: printName }; }); // 加载模块 require([&apos;myModule&apos;], function (my){ my.printName(); }); #语法 requireJS定义了一个函数 define，它是全局变量，用来定义模块 define(id?, dependencies?, factory); id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） dependencies：是一个当前模块依赖的模块名称数组 factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值 #在页面上使用require函数加载模块 require([dependencies], function(){}); require()函数接受两个参数 第一个参数是一个数组，表示所依赖的模块 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 #CMD CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同 #语法 Sea.js 推崇一个模块一个文件，遵循统一的写法 define define(id?, deps?, factory) 因为CMD推崇 一个文件一个模块，所以经常就用文件名作为模块id CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写 factory有三个参数 function(require, exports, module) #require require 是 factory 函数的第一个参数 require(id) require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口 exports exports 是一个对象，用来向外提供模块接口 #module module 是一个对象，上面存储了与当前模块相关联的一些属性和方法 demo // 定义模块 myModule.js define(function(require, exports, module) { var $ = require(&apos;jquery.js&apos;) $(&apos;div&apos;).addClass(&apos;active&apos;); }); // 加载模块 seajs.use([&apos;myModule.js&apos;], function(my){ }); #AMD与CMD区别 关于这两个的区别网上可以搜出一堆文章，简单总结一下 最明显的区别就是在模块定义时对依赖的处理不同 AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require 这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同 很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略 为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。） 同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行 CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的 这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因","categories":[],"tags":[{"name":"Module","slug":"Module","permalink":"http://yoursite.com/tags/Module/"}]},{"title":"Node+React+Webpack+es6+less的环境配置","slug":"React","date":"2016-12-16T10:40:16.000Z","updated":"2016-12-22T08:41:19.256Z","comments":true,"path":"2016/12/16/React/","link":"","permalink":"http://yoursite.com/2016/12/16/React/","excerpt":"#React Demo React环境配置：Node+React+Webpack+es6+Less （清单），案例地址：https://github.com/betrs/ReactDemo.git #安装依赖： 命令中 –save-dev 含义是安装时顺便把配置信息写入到package.json文件中 1.生成一个 package.json文件 ： //使用命令： npm init //（一路默认即可） 2.安装 react 和 react-dom 依赖： //使用命令： npm install react react-dom --save-dev 3.安装 webpack 和 webpack-dev-server 依赖： //使用命令： npm install webpack webpack-dev-server --save-dev 4.安装 babel 依赖： //使用命令： npm install babel-loader babel-core babel-preset-react babel-preset-es2015 --save-dev 5.安装 less css 处理样式依赖： //使用命令： npm install less-loader css-loader style-loader --save-dev 6.安装 url-loader 处理资源依赖： //使用命令： npm install url-loader --save-dev","text":"#React Demo React环境配置：Node+React+Webpack+es6+Less （清单），案例地址：https://github.com/betrs/ReactDemo.git #安装依赖： 命令中 –save-dev 含义是安装时顺便把配置信息写入到package.json文件中 1.生成一个 package.json文件 ： //使用命令： npm init //（一路默认即可） 2.安装 react 和 react-dom 依赖： //使用命令： npm install react react-dom --save-dev 3.安装 webpack 和 webpack-dev-server 依赖： //使用命令： npm install webpack webpack-dev-server --save-dev 4.安装 babel 依赖： //使用命令： npm install babel-loader babel-core babel-preset-react babel-preset-es2015 --save-dev 5.安装 less css 处理样式依赖： //使用命令： npm install less-loader css-loader style-loader --save-dev 6.安装 url-loader 处理资源依赖： //使用命令： npm install url-loader --save-dev #最终目录结构： --React |--node_modules（程序所有依赖） |--components（组件目录） |--wujia（组件wujia） |--images（图片夹子） |--index.jsx |--index.less |--input（组件input） |--images（图片夹子） |-- js.jpg |--input.jsx |--input.less |--blog（组件blog） |--images（图片夹子） |--index.jsx |--index.less |--index.js（入口文件） |--build（输出目录） |--index.html |--bundle.js (输出文件，由webpack打包后生成的) |--package.json |--webpack.config.js #Webpack 配置文件 webpack.config.js 的编写，代码如下（该文件需手动创建取名 webpack.config.js ）： var path = require(&apos;path&apos;); var webpack = require(&apos;webpack&apos;); var ROOT_PATH = path.resolve(__dirname); var APP_PATH = path.resolve(__dirname, &apos;./components/index.js&apos;); var BUILD_PATH = path.resolve(__dirname, &apos;./build&apos;); module.exports = { entry: APP_PATH, //入口文件路径 output: { path: BUILD_PATH, //输出打包后的文件路径并生成 bundle.js文件 filename: &apos;bundle.js&apos; }, module: { loaders: [{ test: /\\.css$/, //正则匹配.css后缀文件，并做相关处理 loader: &apos;style!css&apos; }, { test: /\\.less$/, //正则匹配.less后缀文件，并做相关处理 loader: &apos;style!css!less&apos; }, { test: /\\.(png|jpg)$/, //正则匹配.png或者jpg后缀文件，并做相关处理 loader: &apos;url?limit=50000&apos; }, { test: /\\.(jsx|js)?$/, //正则匹配.jsx或js后缀文件，并做相关处理 loaders: [&apos;babel-loader?presets[]=es2015,presets[]=react&apos;] }] }, entry: [ //自动更新入口配置 &apos;webpack/hot/dev-server&apos;, &apos;webpack-dev-server/client?http://localhost:3000&apos;, APP_PATH ] } #package.json 配置文件 的编写，代码如下： { &quot;name&quot;: &quot;reactdemo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;this is my first react case.&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --port 3000 --devtool eval --progress --colors --hot --content-base build&quot;, &quot;build&quot;: &quot;webpack&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;jasn&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;babel-core&quot;: &quot;^6.20.0&quot;, &quot;babel-loader&quot;: &quot;^6.2.10&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.18.0&quot;, &quot;babel-preset-react&quot;: &quot;^6.16.0&quot;, &quot;react&quot;: &quot;^15.4.1&quot;, &quot;react-dom&quot;: &quot;^15.4.1&quot;, &quot;webpack&quot;: &quot;^1.14.0&quot;, &quot;webpack-dev-server&quot;: &quot;^1.16.2&quot; } } #根据目录所示，我们需要创建两个组件，代码分别如下： 1.wujia组件代码： &quot;use strict&quot;; //开启严格模式 import React from &apos;react&apos;; //导入react依赖 import ReactDOM from &quot;react-dom&quot;; //导入react-dom依赖 /** * 创建一个组件，取名 Wujia * export default 把创建的组件 Wujia 暴露出去 * extends React.Component 让组件继承Component所有属性与方法 **/ export default class Wujia extends React.Component{ render(){ return &lt;a className={this.props.color} href={this.props.src} title={this.props.mes}&gt;{this.props.title}&lt;/a&gt; }; }; 组件Wujia编写的less样式 : @color:blue; .hello{ color:@color; text-decoration: none; &amp;:hover{ text-decoration:underline; } } 2.blog组件代码： &quot;use strict&quot;; //开启严格模式 import React from &quot;react&quot;; //导入react依赖 import ReactDOM from &quot;react-dom&quot;; //导入react-dom依赖 /** * 创建一个组件，取名 Blog * export default 把创建的组件 Blog 暴露出去 * extends React.Component 让组件继承Component所有属性与方法 **/ export default class Blog extends React.Component { render(){ return &lt;a className={this.props.color} href={this.props.src} title={this.props.mes}&gt;{this.props.name}&lt;/a&gt; }; }; 组件blog编写的less样式 : @color:red; .react{ color:@color; text-decoration: none; &amp;:hover{ text-decoration:underline; } } 3.input组件代码： &quot;use strict&quot;; //开启严格模式 import React from &quot;react&quot;; //导入react依赖 import ReactDOM from &quot;react-dom&quot;; //导入react-dom依赖 /** * 创建一个组件，取名 Input * export default 把创建的组件 Input 暴露出去 * extends React.Component 让组件继承Component所有属性与方法 **/ export default class Input extends React.Component{ //初始化状态 constructor(props,context){ super(props,context); this.state = { value: this.props.value }; }; //事件函数（输入框改变触发） changeHandle(ev){ //设置状态 this.setState({ value: ev.target.value }); }; render(){ return ( &lt;div&gt; &lt;input className={this.props.class1} type=&quot;text&quot; value={this.state.value} onChange={this.changeHandle.bind(this)}/&gt; &lt;p className={this.props.class2}&gt;{this.state.value}&lt;/p&gt; &lt;img className={this.props.class3} src={this.props.src}/&gt; &lt;/div&gt; ); }; }; 组件input编写的less样式 : .input{width: 180px;height: 30px;line-height: 30px;padding:0 10px;border:1px solid #ddd;font-size:14px;color:#333;} .tishi{display: inline-block;font-size:16px;color:green;margin-left:20px;} .img{display:block;margin-top:20px;} #创建页面 index.html （ build目录下 ）来使用前面创建的两个组件，代码如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;wrap&quot;&gt;&lt;div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; #使用webpack打包 Webpack 是一个前端模块加载兼打包工具，可以对 JS、CSS 和 图片 等都作为模块来使用和处理。对不同类型的需要编译的文件，需要使用相应的加载器（比如用 babel 转译 ES6）。 另外，由于 Webpack 需要一个入口文件来进行分析和处理，需要先将 React 组件引入到一个主文件。 从前文的目录结构可以看出， components/index.js 就是这个主文件，它的代码如下： &quot;use strict&quot;; import React from &quot;react&quot;; //导入react依赖 import ReactDOM from &quot;react-dom&quot;; //导入react-dom依赖 import Wujia from &quot;./wujia/index.jsx&quot;;//导入wujia组件 import Blog from &quot;./blog/index.jsx&quot;;//导入blog组件 import Input from &quot;./input/input.jsx&quot;;//导入input组件 import url from &quot;./input/images/js.jpg&quot;;//导入图片资源 import &quot;./wujia/index.less&quot;;//导入wujia组件样式 import &quot;./blog/index.less&quot;;//导入blog组件样式 import &quot;./input/input.less&quot;;//导入input组件样式 //创建一个input组件数据对象 const obj2 = { value:&quot;吴佳&quot;, class1:&quot;input&quot;, class2:&quot;tishi&quot;, class3:&quot;img&quot;, src:url }; //开始渲染DOM结构 ReactDOM.render( ( &lt;div&gt; &lt;h1&gt; &lt;Wujia color=&quot;hello&quot; title=&quot;吴佳&quot; src=&quot;https://www.github.com/betrs&quot; mes=&quot;吴佳Github&quot;/&gt; &lt;Blog color=&quot;react&quot; name=&quot;博客&quot; src=&quot;http://www.wujiabk.com&quot; mes=&quot;吴佳博客&quot;/&gt; &lt;/h1&gt; &lt;Input {...obj2}/&gt; &lt;/div&gt; ), document.querySelector(&quot;.wrap&quot;) ); 最后，需要将编译打包后的文件 bundle.js 引入到 index.html 中： &lt;body&gt; ... &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; #构建和启动 #构建 前面的开发完成后，需要执行 webpack.config.js 中的构建任务，生成 bundle.js ，可以看到在 package.json 中我们在scripts内配置了”build”：”webpack”： &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot; } 然后执行命令 npm run build 完成构建，此时打开 index.html ，即可看到效果。 #启动服务器 但这种方式显得略 low，一是它是双击以文件的形式打开 HTML 页面，二是每次有更改都要手动执行 npm run build 重新打包。 一种更好的方式是启动一个静态资源服务器，监听文件内容修改并自动打包。在这里用的是前面安装好的 webpack-dev-server ，在 package.json 配置中可以看到如下代码： &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --port 3000 --devtool eval --progress --colors --hot --content-base build&quot; } 简单解释一下 dev 中各个参数的含义： webpack-dev-server 在 localhost:3000（不设置端口默认是8080） 建立一个 Web 服务器； –devtool eval 映射编译好的源码，用于调试； –progress 显示代码打包进度； –colors 表示在命令行中显示颜色； –content-base 来指定 server 启动后的内容目录。 执行命令 npm run dev 启动 server，此时打开浏览器输入 http://localhost:3000 ，即可看到效果。修改一下 Hello 或者 World 组件中的内容，刷新页面，你会发现浏览器中内容也相应改变了。 #自动刷新 前面实现了对文件修改的监听和自动打包，但浏览器还需要手动刷新。其实可以在 Webpack 的配置文件中增加一个入口点，实现自动刷新。 在webpack.config.js中我们可以看到如下代码： ··· entry: [ &apos;webpack/hot/dev-server&apos;, &apos;webpack-dev-server/client?http://localhost:3000&apos;, APP_PATH ], ··· 这样，应用在修改后，浏览器就会实时监听进行自动刷新了。 #说明：如果设置了自动更新入口，我们需要在package.json配置文件中scripts中设置dev，代码如下： ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --port 3000 --devtool eval --progress --colors --hot --content-base build&quot;, &quot;build&quot;: &quot;webpack&quot;, &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; } ... 最后执行命令： npm run dev //就可以跑起来了，然后可以试试是不是自动更新。 如果你是直接从github拉下来的demo，首先cd到ReactDemo目录,然后执行：npm install （自动安装依赖），然后输入上方npm run dev 就行了。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"JQuery3中新增的功能","slug":"JQuery3NewFunction","date":"2016-12-14T01:47:45.000Z","updated":"2016-12-16T02:49:40.154Z","comments":true,"path":"2016/12/14/JQuery3NewFunction/","link":"","permalink":"http://yoursite.com/2016/12/14/JQuery3NewFunction/","excerpt":"从jQuery 震撼整个 Web ，至今已有十年了，我们有很好的理由一直坚持使用维护它。jQuery为用户提供了 DOM 进行操作，执行 Ajax 请求，创建动画等等，极为友好的接口。此外，与 DOM API 不同的是，jQuery 采用了 复合模式（composite pattern）。 正因为如此，你可以在一个jQuery集合上调用jQuery方法，而不用担心集合包含的元素数量（零，一个或多个）。 在未来的几周内，随着 jQuery 3 的发布，jQuery 会到达一个重要的里程碑。jQuery 3 修复了很多 bug，增加了新的方法，弃用并移除了一些功能，并改变了一些功能的行为。在这篇文章中，我重点讲解jQuery 3所带来的一些最大的变化。 #新特性（New Features）在下面的章节中，我将讨论jQuery 3中新增的重要特性。","text":"从jQuery 震撼整个 Web ，至今已有十年了，我们有很好的理由一直坚持使用维护它。jQuery为用户提供了 DOM 进行操作，执行 Ajax 请求，创建动画等等，极为友好的接口。此外，与 DOM API 不同的是，jQuery 采用了 复合模式（composite pattern）。 正因为如此，你可以在一个jQuery集合上调用jQuery方法，而不用担心集合包含的元素数量（零，一个或多个）。 在未来的几周内，随着 jQuery 3 的发布，jQuery 会到达一个重要的里程碑。jQuery 3 修复了很多 bug，增加了新的方法，弃用并移除了一些功能，并改变了一些功能的行为。在这篇文章中，我重点讲解jQuery 3所带来的一些最大的变化。 #新特性（New Features）在下面的章节中，我将讨论jQuery 3中新增的重要特性。 #for…of 循环jQuery 3 将提供for…of循环语句，可以用来遍历一个jQuery集合所有的 DOM 元素。这种新的迭代器ECMAScript 2015（又名的ECMAScript6）规范的一部分。它能实现对可遍历对象（包括Array、Map、Set 等）的循环。 当使用这个新的迭代方法时，您每次接收的值不是一个jQuery集合，而是一个DOM元素。当你对一个jQuery集合执行操作时，这个新的迭代方法可以少许改善你的代码。 为了理解这个迭代方法是如何工作的，假设你想给页面中每个input元素分配一个 ID。在 jQuery 3 之前，你可以这样写： var $inputs = $(&apos;input&apos;); for(var i = 0; i &lt; $inputs.length; i++) { $inputs[i].id = &apos;input-&apos; + i; } 而在 jQuery 3 中，你可以这样写： var $inputs = $(&apos;input&apos;); var i = 0; for(var input of $inputs) { input.id = &apos;input-&apos; + i++; } #$.get() 和 $.post()的新签名jQuery 3 为 $.get() 和 $.post() 工具函数增加了新签名，为的是使得它们和 $.ajax() 的接口风格保持一致。新签名是这样的： $.get([settings]) $.post([settings]) settings 是一个可以具有许多属性的对象。这是对象和 提供给$.ajax() 的对象 是相同的。更多详细的介绍，详细介绍，请参考 $.ajax()页面。 传递给$.get() 和 $.post() 的对象，跟传递给 $.ajax() 的对象相比，唯一的区别是前者 method 属性总是会被忽略。其原因是，$.get() 和 $.post() 都有一个预设的HTTP方法来执行Ajax请求（ $.get() 用 GET，而 $.post() 用 POST）。一般说来，你不要用 $.get()尝试发送 POST 请求。 考虑下面这段代码： $.get({ url: &apos;https://www.audero.it&apos;, method: &apos;POST&apos; // This property is ignored }); 尽管设置了method属性，该语句还是不能发送 POST 请求，而只能发送 GET 请求。 #采用 requestAnimationFrame() 来实现动画所有现代浏览器，包括Internet Explorer10及以上版本，都支持 requestAnimationFrame。jQuery 3 将会在内部采用这个 API 来实现动画，以便达到更流畅、更省CPU资源的动画效果。 #unwrap()jQuery 3 为 unwrap() 方法增加了一个可选的选择器参数。这个方法的新签名为： unwrap([selector]) 有了这一变化，你就可以传入包含一个选择器表达式的字符串，在父元素内进行匹配。如果存在匹配，匹配的子元素将被解包;否则，不进行任何操作。 被变更的特性jQuery 3 还修改了一些特性的行为。 :visible 和 :hiddenjQuery 3修改了 :visible 与 :hidden 过滤器的含义。只要元素具有任何布局盒，包括那些宽度和/或高度为0的情况，则元素被认为是:visible。比如说，br 元素和没有内容的内联元素进可以通过 :visible过滤器进行选择。 所以，假如页面有如下标记： 然后执行下面的语句： console.log($(‘body :visible’).length);在 jQuery 1.x 和 2.x 中，你得到的结果会是 0；但在 jQuery 3 中，你会得到 2。#data()另一个重要变化是跟 data() 方法的行为有关。调整主要是为了让该方法符合 Dataset API 规范。jQuery 3 将所有属性的键都改为驼峰式大小写形式。要理解这个变化，先看下面这个例子。如果你使用 jQuery 3 之前的版本，你可以写如下代码： var $elem = $(‘#container’); $elem.data({ ‘my-property’: ‘hello’ }); console.log($elem.data());您将在控制台上获得如下结果： {my-property: “hello”}而在jQuery 3 中，你会获得如下结果： {myProperty: “hello”}请注意，在 jQuery 3 中，属性名已经变成了驼峰形式，没有横杠（连字符）；而在以前的版本中，属性名会保持全小写，并原样保留横杠（连字符）。#Deferred 对象jQuery 3改变了Deferred 对象的行为，Promise 对象的前身，改善与 Promise/A+ 提案的兼容性。这个对象及其历史非常有意思，你可以读读官方文档，或者看看我的书 《jQuery 实战，第 3 版》，这本书也涵盖了 jQuery 3。在 jQuery 1.x 和 2.x 中，传入 Deferred 中的回调函数中如果出现未捕获异常，会导致程序停止执行。而原生的 Promise 对象并非如此，它会抛出异常，并不断向上冒泡，直至到达 window.onerror（通常）。如果你没有定义一个函数来处理这个错误事件的话（通常我们都不会这么做），则会显示异常消息，程序终止执行。jQuery 3 会遵循原生的 Promise 对象的模式。因此，抛出的异常将被视为一个失败状态（rejection），从而执行失败回调。完成之后，整个进程就继续执行，后续的成功回调将被执行。为了让你更好地理解这个差异，让我们来看一个小例子。考虑下面的代码： var deferred = $.Deferred(); deferred .then(function() { throw new Error(‘An error’); }) .then( function() { console.log(‘Success 1’); }, function() { console.log(‘Failure 1’); } ) .then( function() { console.log(‘Success 2’); }, function() { console.log(‘Failure 2’); } );#deferred.resolve();在 jQuery 1.x 和 2.x 中，只执行第一个函数（抛出错误的函数）会被执行到。此外，由于我们没有为window.onerror 定义任何事件处理函数，所以控制台将输出消息：“Uncaught Error: An error”，而且程序的执行将中止。而在 jQuery 3 中，行为则完全不同的。你将在控制台中看到 “Failure 1” 和 “Success 2” 两条消息。异常将会被第一个失败回调处理，一旦被处理，则继续执行下面的成功函数。#SVG 文档没有哪一个 jQuery 版本，包括 jQuery 3，正式支持 SVG 文档。不过事实上有很多方法是可以正常工作的，另外一些方法，比如操作类名的方法，已经在 jQuery 3 中进行了更新，因此也适用。因此，在未来的版本中，你应该可以放心使用诸如 addClass() 和 hasClass() 这样的方法来操作 SVG 文档了。已废弃、已移除的方法和属性除了前面说的改进，jQuery 也移除、废弃了一些特性。废弃bind(),unbind(),delegate()和undelegate()jQuery 以前引入的 on() 方法提供了统一的访问接口，取代 bind()、delegate() 以及 live() 方法。与此同时，jQuery 用 off() 方法来取代 unbind()、undelegated() 及 die() 方法。bind()、delegate()、unbind() 和 undelegate() 今后不建议使用，但是并没有采取进一步的行动。jQuery 3 已经废弃这些方法，并计划在未来的版本（可能是 jQuery 4）中移除它们，要坚持在项目中使用 on() 和 off() 方法，这样你就不用担心未来版本的变更了。移除 load(), unload() 和 error()方法jQuery 3 彻底抛弃了已经废弃的 load()、unload() 和 error() 方法。这些方法在很早以前（从 jQuery 1.8 开始）就已经被标记为废弃了，但仍一直存在。如果你正在使用的插件仍然依赖这些方法，那么升级到 jQuery 3 的时候，代码就会出错。因此，在升级过程中要注意。移除 context, support 和 selectorjQuery 3 彻底抛弃了已经废弃的 context、support 和 selector 属性。如前所述，如果项目中仍然使用着这些属性，或者某个插件仍在依赖这些属性，那么更新到 jQuery 3 时，代码就会出错。#Bugs 修复jQuery 3 修复了以前版本中的一些重大 Bug。在下面的章节中，我将着重介绍其中两处，因为这两处会对你的编码产生重大影响width() 和 height()的返回值不再四舍五入jQuery 3 修复了 width()、height() 和其它相关方法中的一个 bug。这些方法的返回值将不再四舍五入取整到像素了，因为，这使得在某些情况下很难，对元素进行定位。要理解这个问题，让我们假设你有一个具有100像素的宽度的容器元素，这个元素有宽度均为三分之一（即 33.333333%）的3个子元素： My name is Aurelio De Rosa 在 jQuery 3 以前的版本中，如果你尝试通过以下代码来获取子元素的宽度…… $(&apos;.container div&apos;).width(); ……那么你得到结果将是 33。原因在于 jQuery 会将 33.33333 这个值四舍五入取整。而在 jQuery 3 中，这个 Bug 已经得到修复，你的结果会更精确（比如会得到浮点数）。 #wrapAll()jQuery的新版本中还修复 wrapAll() 方法的一个bug，这个bug会在传递一个函数给 wrapAll() 方法时发生。在 jQuery 3 以前的版本中，当一个函数被传给 wrapAll() 方法时，它会把 jQuery 集合中的每个元素单独包裹起来。换句话说，这种行为和把一个函数传给 wrap() 时的行为是完全一样的。 除了修复这个问题，因为这种函数在 jQuery 3 中只会被调用一次，所以jQuery 集合元素的索引不可能被传入。最后，该函数上下文（this）将指向 jQuery 集合中的第一个元素。 下载 jQuery 3 beta 1如果此文让你产生了兴趣，你可以试试 jQuery 3 的第一个 beta 版。通过下面两个 URL 都可以下载到它。 未压缩版本: https://code.jquery.com/jquery-3.0.0-beta1.js压缩版本: https://code.jquery.com/jquery-3.0.0-beta1.min.js 它也可在npm，通过运行以下命令下载它：npm install jquery@3.0.0-beta1 #总结很多人在说jQuery 已死，认为在现代网页开发中已经没有一席之地了。然而，jQuery 的开发仍在继续，客观的统计数据（在排名前一百万名的网站中占有率高达 78.5%）驳斥这些说法。 在本文中，我已经带你了解了一遍 jQuery 3 将会带来的一些重大变化。或许你已经注意到了，这个版本是可能对你现有的项目产生太大的影响，因为没有引入太多许多重大更改。尽管如此，仍然需要注意一些因素，比如 Deferred 对象的改进。就像更新第三方依赖所经常要面的那样，对项目一定要做一个复查，从而防止意外行为或功能崩溃的情况出现。","categories":[],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"总结40条常见移动端Web页面问题解决方案","slug":"webProblem","date":"2016-12-09T01:20:09.000Z","updated":"2016-12-09T01:31:10.444Z","comments":true,"path":"2016/12/09/webProblem/","link":"","permalink":"http://yoursite.com/2016/12/09/webProblem/","excerpt":"#1、安卓浏览器看背景图片，有些设备会模糊。 用同等比例的图片在PC机上很清楚，但是手机上很模糊，原因是什么呢？ 经过研究，是devicePixelRatio作怪，因为手机分辨率太小，如果按照分辨率来显示网页，这样字会非常小，所以苹果当初就把iPhone 4的960640分辨率，在网页里只显示了480320，这样devicePixelRatio＝2。现在android比较乱，有1.5的，有2的也有3的。 想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况都是用2倍）。例如一个div的宽高是100100，背景图必须得200200，然后background-size:contain;，这样显示出来的图片就比较清晰了。 代码如下： background:url(../images/icon/all.png) no-repeat center center; -webkit-background-size:50px 50px; background-size: 50px 50px;display:inline-block; width:100%; height:50px; 或者指定 background-size:contain;都可以，大家试试！","text":"#1、安卓浏览器看背景图片，有些设备会模糊。 用同等比例的图片在PC机上很清楚，但是手机上很模糊，原因是什么呢？ 经过研究，是devicePixelRatio作怪，因为手机分辨率太小，如果按照分辨率来显示网页，这样字会非常小，所以苹果当初就把iPhone 4的960640分辨率，在网页里只显示了480320，这样devicePixelRatio＝2。现在android比较乱，有1.5的，有2的也有3的。 想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况都是用2倍）。例如一个div的宽高是100100，背景图必须得200200，然后background-size:contain;，这样显示出来的图片就比较清晰了。 代码如下： background:url(../images/icon/all.png) no-repeat center center; -webkit-background-size:50px 50px; background-size: 50px 50px;display:inline-block; width:100%; height:50px; 或者指定 background-size:contain;都可以，大家试试！ #2、图片加载 若您遇到图片加载很慢的问题，对这种情况，手机开发一般用canvas方法加载： 具体的canvas API 参见：http://javascript.ruanyifeng.com/htmlapi/canvas.html 下面举例说明一个canvas的例子： &lt;li&gt;&lt;canvas&gt;&lt;/canvas&gt;&lt;/li&gt; js动态加载图片和li 总共举例17张图片！ var total=17; var zWin=$(window); var render=function(){ var padding=2; var winWidth=zWin.width(); var picWidth=Math.floor((winWidth-padding*3)/4); var tmpl =&apos;&apos;; for (var i=1;i&lt;=totla;i++){ var p=padding; var imgSrc=&apos;img/&apos;+i+&apos;.jpg&apos;; if(i%4==1){ p=0; } tmpl +=&apos;&lt;li style=&quot;width:&apos;+picWidth+&apos;px;height:&apos;+picWidth+&apos;px;padding-left:&apos;+p+&apos;px;padding-top:&apos;+padding+&apos;px;&quot;&gt;&lt;canvas id=&quot;cvs_&apos;+i+&apos;&quot;&gt;&lt;/canvas&gt;&lt;/li&gt;&apos;; var imageObj = new Image(); imageObj.index = i; imageObj.onload = function(){ var cvs =$(&apos;#cvs_&apos;+this.index)[0].getContext(&apos;2d&apos;); cvs.width = this.width; cvs.height=this.height; cvs.drawImage(this,0,0); } imageObj.src=imgSrc; } } render(); #3、假如手机网站不用兼容IE浏览器，一般我们会使用zeptojs。 zeptojs内置Touch events方法，具体可以看http://zeptojs.com/#Touch events 看了一下zeptio新版的API，已经支持IE10以上浏览器，对zeptojs可以选择使用！ #4、防止手机中网页放大和缩小。 这点是最基本的，最为手机网站开发者来说应该都知道的，就是设置meta中的viewport 还有就是，有些手机网站我们看到如下声明： &lt;!DOCTYPE html PUBLIC &quot;-//WAPFORUM//DTD XHTML Mobile 1.0//EN&quot; &quot;http://www.wapforum.org/DTD/xhtml-mobile10.dtd&quot;&gt; 设置了DTD的方式是XHTML的写法，假如我们页面运用的是html5，可以不用设置DTD,直接声明&lt;!DOCTYPE html&gt;。 使用viewport使页面禁止缩放。 通常把user-scalable设置为0来关闭用户对页面视图缩放的行为 &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=0&quot; /&gt; 但是为了更好的兼容，我们会使用完整的viewport设置。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot; /&gt; 当然，user-scalable=0,有的人也写成user-scalable=no，都可以的。 #5、apple-mobile-web-app-capable apple-mobile-web-app-capable是设置Web应用是否以全屏模式运行。 语法： &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; 说明：如果content设置为yes，Web应用会以全屏模式运行，反之，则不会。content的默认值是no，表示正常显示。你可以通过只读属性window.navigator.standalone来确定网页是否以全屏模式显示。 #6、format-detection format-detection 启动或禁用自动识别页面中的电话号码。语法： &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; 说明：默认情况下，设备会自动识别任何可能是电话号码的字符串。设置telephone=no可以禁用这项功能。 #7、html5调用安卓或者ios的拨号功能 html5提供了自动调用拨号的标签，只要在a标签的href中添加tel:就可以了。如下： &lt;a href=&quot;tel:10010&quot;&gt;10010&lt;/a&gt; #8、html5GPS定位功能 具体请看：http://www.w3school.com.cn/html5/html_5_geolocation.asp #9、上下拉动滚动条时卡顿、慢 body { -webkit-overflow-scrolling: touch; overflow-scrolling: touch; } #10、禁止复制、选中文本 Element { -webkit-user-select: none; -moz-user-select: none; -khtml-user-select: none; user-select: none; } 解决移动设备可选中页面文本(视产品需要而定) #11、长时间按住页面出现闪退 element { -webkit-touch-callout: none; } #12、iphone及ipad下输入框默认内阴影 Element{ -webkit-appearance: none; } #13、ios和android下触摸元素时出现半透明灰色遮罩 Element { -webkit-tap-highlight-color:rgba(255,255,255,0) } #14、active兼容处理 即 伪类 :active 失效 方法一：body添加ontouchstart &lt;body ontouchstart=&quot;&quot;&gt; 方法二：js给 document 绑定 touchstart 或 touchend 事件 &lt;style&gt; a { color: #000; } a:active { color: #fff; } &lt;/style&gt; &lt;a herf=foo &gt;bar&lt;/a&gt; &lt;script&gt; document.addEventListener(&apos;touchstart&apos;,function(){},false); &lt;/script&gt; #15、动画定义3D启用硬件加速 Element { -webkit-transform:translate3d(0, 0, 0) transform: translate3d(0, 0, 0); } #16、Retina屏的1px边框 具体请百度谷歌关键字，解决方案有很多 #17、webkit mask 兼容处理 某些低端手机不支持css3 mask，可以选择性的降级处理。比如可以使用js判断来引用不同class： if( &apos;WebkitMask&apos; in document.documentElement.style){ alert(&apos;支持mask&apos;); } else { alert(&apos;不支持mask&apos;); } #18、旋转屏幕时，字体大小调整的问题 html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 { -webkit-text-size-adjust:100%; } #19、transition闪屏 /设置内嵌的元素在 3D 空间如何呈现：保留3D / -webkit-transform-style: preserve-3d; / 设置进行转换的元素的背面在面对用户时是否可见：隐藏 / -webkit-backface-visibility:hidden; #20、圆角bug 某些Android手机圆角失效 background-clip: padding-box; #21、顶部状态栏背景色 &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&gt; 说明：除非你先使用apple-mobile-web-app-capable指定全屏模式，否则这个meta标签不会起任何作用。 如果content设置为default，则状态栏正常显示。如果设置为blank，则状态栏会有一个黑色的背景。如果设置为blank-translucent，则状态栏显示为黑色半透明。 如果设置为default或blank，则页面显示在状态栏的下方，即状态栏占据上方部分，页面占据下方部分，二者没有遮挡对方或被遮挡。 如果设置为blank-translucent，则页面会充满屏幕，其中页面顶部会被状态栏遮盖住（会覆盖页面20px高度，而iphone4和itouch4的Retina屏幕为40px）。 默认值是default。 #22、设置缓存 &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&gt; 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。 #23、桌面图标 &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;touch-icon-iphone.png&quot; /&gt; &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;76x76&quot; href=&quot;touch-icon-ipad.png&quot; /&gt; &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;120x120&quot; href=&quot;touch-icon-iphone-retina.png&quot; /&gt; &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;152x152&quot; href=&quot;touch-icon-ipad-retina.png&quot; /&gt; iOS下针对不同设备定义不同的桌面图标。如果不定义则以当前屏幕截图作为图标。 上面的写法可能大家会觉得会有默认光泽，下面这种设置方法可以去掉光泽效果，还原设计图的效果！ &lt;link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;touch-icon-iphone.png&quot; /&gt; 图片尺寸可以设定为5757（px）或者Retina可以定为114114（px），ipad尺寸为72*72（px) #24、启动画面 &lt;link rel=&quot;apple-touch-startup-image&quot; href=&quot;start.png&quot;/&gt; iOS下页面启动加载时显示的画面图片，避免加载时的白屏。可以通过madia来指定不同的大小： &lt;!--iPhone--&gt; &lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone Retina --&gt; &lt;link href=&quot;apple-touch-startup-image-640x920.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone 5 --&gt; &lt;link rel=&quot;apple-touch-startup-image&quot; media=&quot;(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)&quot; href=&quot;apple-touch-startup-image-640x1096.png&quot;&gt; &lt;!-- iPad portrait --&gt; &lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad landscape --&gt; &lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina portrait --&gt; &lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina landscape --&gt; &lt;link href=&quot;apple-touch-startup-image-1496x2048.png&quot;media=&quot;(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot;rel=&quot;apple-touch-startup-image&quot; /&gt; #25、浏览器私有及其它meta 以下属性在项目中没有应用过，可以写一个demo测试以下！ &lt;!-- QQ浏览器私有 --&gt; &lt;!-- 全屏模式 --&gt; &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;&gt; &lt;!-- 强制竖屏 --&gt; &lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- 强制横屏 --&gt; &lt;meta name=&quot;x5-orientation&quot; content=&quot;landscape&quot;&gt; &lt;!-- 应用模式 --&gt; &lt;meta name=&quot;x5-page-mode&quot; content=&quot;app&quot;&gt; &lt;!-- UC浏览器私有 --&gt; &lt;!-- 全屏模式 --&gt; &lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; &lt;!-- 强制竖屏 --&gt; &lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt; &lt;!-- 强制横屏 --&gt; &lt;meta name=&quot;screen-orientation&quot; content=&quot;landscape&quot;&gt; &lt;!-- 应用模式 --&gt; &lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;&gt; 其它,针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 &lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; 微软的老式浏览器 &lt;meta name=&quot;MobileOptimized&quot; content=&quot;320&quot;&gt; windows phone 点击无高光 &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; #26、 IOS中input键盘事件keyup、keydown、keypress支持不是很好 问题是这样的，用input search做模糊搜索的时候，在键盘里面输入关键词，会通过ajax后台查询，然后返回数据，然后再对返回的数据进行关键词标红。 用input监听键盘keyup事件，在安卓手机浏览器中是可以的，但是在ios手机浏览器中变红很慢，用输入法输入之后，并未立刻相应keyup事件，只有在通过删除之后才能相应！ 解决办法：可以用html5的oninput事件去代替keyup &lt;input type=&quot;text&quot; id=&quot;testInput&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&apos;testInput&apos;).addEventListener(&apos;input&apos;, function(e){ var value = e.target.value; }); &lt;/script&gt; 然后就达到类似keyup的效果！ #27、h5网站input 设置为type=number的问题 h5网页input 的type设置为number一般会产生三个问题，一个问题是maxlength属性不好用了。另外一个是form提交的时候，默认给取整了。三是部分安卓手机出现样式问题。 问题一解决，我目前用的是js。如下 &lt;input type=&quot;number&quot; oninput=&quot;checkTextLength(this ,10)&quot;&gt; function checkTextLength(obj, length) { if(obj.value.length &gt; length) { obj.value = obj.value.substr(0, length); } } 问题二，是因为form提交默认做了表单验证，step默认是1,要设置step属性，假如保留2位小数，写法如下： &lt;input type=&quot;number&quot; step=&quot;0.01&quot; /&gt; 关于step，我在这里做简单的介绍，input 中type=number，一般会自动生成一个上下箭头，点击上箭头默认增加一个step，点击下箭头默认会减少一个step。number中默认step是1。也就是step=0.01,可以允许输入2位小数，并且点击上下箭头分别增加0.01和减少0.01。 假如step和min一起使用，那么数值必须在min和max之间。 看下面的例子： &lt;input type=&quot;number&quot; step=&quot;3.1&quot; min=&quot;1&quot; /&gt; 输入框可以输入哪些数字？ 首先，最小值是1，那么可以输入1.0，第二个是可以输入（1+3.1）那就是4.1,以此类推，每次点击上下箭头都会增加或者减少3.1，输入其他数字无效。这就是step的简单介绍。 问题三，去除input默认样式 input[type=number] { -moz-appearance:textfield; } input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; } #28、ios 设置input 按钮样式会被默认样式覆盖 解决方式如下： input, textarea { border: 0; -webkit-appearance: none; } 设置默认样式为none #29、IOS键盘字母输入，默认首字母大写 解决方案，设置如下属性 &lt;input type=&quot;text&quot; autocapitalize=&quot;off&quot; /&gt; #30、select 下拉选择设置右对齐 设置如下： select option { direction: rtl; } #31、通过transform进行skew变形，rotate旋转会造成出现锯齿现象 可以设置如下： -webkit-transform: rotate(-4deg) skew(10deg) translateZ(0); transform: rotate(-4deg) skew(10deg) translateZ(0); outline: 1px solid rgba(255,255,255,0) #32、移动端点击300ms延迟 300ms尚可接受，不过因为300ms产生的问题，我们必须要解决。300ms导致用户体验并不是很好，解决这个问题，我们一般在移动端用tap事件来取代click事件。 推荐两个js，一个是fastclick，一个是tap.js 关于300ms延迟，具体请看：http://thx.github.io/mobile/300ms-click-delay/ #33、移动端点透问题 案例如下： &lt;div id=&quot;haorooms&quot;&gt;点头事件测试&lt;/div&gt; &lt;a href=&quot;#&quot;&gt;www.xxx.com&lt;/a&gt; div是绝对定位的蒙层,并且z-index高于a。而a标签是页面中的一个链接，我们给div绑定tap事件： $(&apos;#haorooms&apos;).on(&apos;tap&apos;,function(){ $(&apos;#haorooms&apos;).hide(); }); 我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。 原因： touchstart 早于 touchend 早于click。 亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。 解决：（1）尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。（2）用fastclick，https://github.com/ftlabs/fastclick（3）用preventDefault阻止a标签的click（4）延迟一定的时间(300ms+)来处理事件 （不推荐）（5）以上一般都能解决，实在不行就换成click事件。 下面介绍一下touchend事件，如下： $(&quot;#haorooms&quot;).on(&quot;touchend&quot;, function (event) { event.preventDefault(); }); #34、消除 IE10 里面的那个叉号 input:-ms-clear{display:none;} #35、关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等) iOS 浏览器横屏时会重置字体大小，设置 text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% 。 -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-size-adjust: 100%; #36、关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格 可以通过正则去掉 this.value = this.value.replace(/\\u2006/g, &apos;&apos;); #37、移动端 HTML5 audio autoplay 失效问题 这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。 解决方法思路：先通过用户 touchstart 触碰，触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。 解决代码： document.addEventListener(&apos;touchstart&apos;, function () { document.getElementsByTagName(&apos;audio&apos;)[0].play(); document.getElementsByTagName(&apos;audio&apos;)[0].pause(); }); #38、移动端 HTML5 input date 不支持 placeholder 问题 这个我感觉没有什么好的解决方案，用如下方法 &lt;input placeholder=&quot;Date&quot; class=&quot;textbox-n&quot; type=&quot;text&quot; onfocus=&quot;(this.type=&apos;date&apos;)&quot; id=&quot;date&quot;&gt; 有的浏览器可能要点击两遍！ #39、部分机型存在type为search的input，自带close按钮样式修改方法 有些机型的搜索input控件会自带close按钮（一个伪元素），而通常为了兼容所有浏览器，我们会自己实现一个，此时去掉原生close按钮的方法为 #Search::-webkit-search-cancel-button{ display: none; } 如果想使用原生close按钮，又想使其符合设计风格，可以对这个伪元素的样式进行修改。 #40、唤起select的option展开zepto方式: $(sltElement).trrgger(&quot;mousedown&quot;); 原生js方式: function showDropdown(sltElement) { var event; event = document.createEvent(&apos;MouseEvents&apos;); event.initMouseEvent(&apos;mousedown&apos;, true, true, window); sltElement.dispatchEvent(event); };","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"工作常用的Git命令","slug":"gitCommand","date":"2016-12-06T05:31:11.000Z","updated":"2016-12-06T05:41:07.857Z","comments":true,"path":"2016/12/06/gitCommand/","link":"","permalink":"http://yoursite.com/2016/12/06/gitCommand/","excerpt":"我每天使用 Git ，但是很多命令记不住。一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 #一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url]","text":"我每天使用 Git ，但是很多命令记不住。一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 #一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] #二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; #三、增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] #四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... #五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] #六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] #七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog #八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all #九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop #十、其他 # 生成一个可供发布的压缩包 $ git archive","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"12 个 CSS 高级技巧汇总","slug":"cssSkill","date":"2016-12-06T05:19:51.000Z","updated":"2016-12-06T05:26:13.750Z","comments":true,"path":"2016/12/06/cssSkill/","link":"","permalink":"http://yoursite.com/2016/12/06/cssSkill/","excerpt":"下面这些CSS高级技巧，一般人我可不告诉他哦。 使用 :not() 在菜单上应用/取消应用边框 给body添加行高 所有一切都垂直居中 逗号分隔的列表 使用负的 nth-child 选择项目 对图标使用SVG 优化显示文本 对纯CSS滑块使用 max-height 继承 box-sizing 表格单元格等宽 用Flexbox摆脱外边距的各种hack 使用属性选择器用于空链接 使用 :not() 在菜单上应用/取消应用边框 先给每一个菜单项添加边框 / add border / .nav li { border-right: 1px solid #666; }","text":"下面这些CSS高级技巧，一般人我可不告诉他哦。 使用 :not() 在菜单上应用/取消应用边框 给body添加行高 所有一切都垂直居中 逗号分隔的列表 使用负的 nth-child 选择项目 对图标使用SVG 优化显示文本 对纯CSS滑块使用 max-height 继承 box-sizing 表格单元格等宽 用Flexbox摆脱外边距的各种hack 使用属性选择器用于空链接 使用 :not() 在菜单上应用/取消应用边框 先给每一个菜单项添加边框 / add border / .nav li { border-right: 1px solid #666; } ……然后再除去最后一个元素…… // remove border / .nav li:last-child { border-right: none; } ……可以直接使用 :not() 伪类来应用元素： .nav li:not(:last-child) { border-right: 1px solid #666; } 这样代码就干净，易读，易于理解了。当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）： .nav li:first-child ~ li { border-left: 1px solid #666; } 给 body添加行高你不需要分别添加 line-height 到每个 ，等。只要添加到 body 即可： body { line-height: 1;} 这样文本元素就可以很容易地从 body 继承。所有一切都垂直居中要将所有元素垂直居中，太简单了： html, body { height: 100%; margin: 0;}body { -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex; } 看，是不是很简单。注：在IE11中要小心flexbox。逗号分隔的列表让HTML列表项看上去像一个真正的，用逗号分隔的列表： ul &gt; li:not(:last-child)::after { content: &quot;,&quot;; } 对最后一个列表项使用 :not() 伪类。使用负的 nth-child 选择项目在CSS中使用负的 nth-child 选择项目1到项目n。 li { display: none;}/* select items 1 through 3 and display them */li:nth-child(-n+3) { display: block; } 就是这么容易。对图标使用SVG我们没有理由不对图标使用SVG： .logo { background: url(&quot;logo.svg&quot;); } SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。优化显示文本有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你： html { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility; } 注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。对纯CSS滑块使用 max-height使用 max-height 和溢出隐藏来实现只有CSS的滑块： .slider ul { max-height: 0; overlow: hidden;}.slider:hover ul { max-height: 1000px; transition: .3s ease; } 继承 box-sizing让 box-sizing 继承 html： html { box-sizing: border-box; } *, *:before, *:after { box-sizing: inherit; } 这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。表格单元格等宽表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽： .calendar { table-layout: fixed; } 用Flexbox摆脱外边距的各种hack当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了： .list { display: flex; justify-content: space-between; } .list .person { flex-basis: 23%; } 现在，列表分隔符就会在均匀间隔的位置出现。使用属性选择器用于空链接当 元素没有文本值，但 href 属性有链接的时候显示链接： a[href^=&quot;http&quot;]:empty::before { content: attr(href); } 相当方便。支持这些高级技巧在Chrome、Firefox、Safari、Edge的当前版本，以及IE11中都能有效工作。 转自：http://www.imooc.com/article/1794","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JavaScript字符串转换为数字的方法","slug":"stringTurnNumber","date":"2016-12-01T01:56:42.000Z","updated":"2016-12-01T01:59:34.484Z","comments":true,"path":"2016/12/01/stringTurnNumber/","link":"","permalink":"http://yoursite.com/2016/12/01/stringTurnNumber/","excerpt":"#1. 函数转换parseInt()和parseFloat()分别用来将数字型字符串或数字转换为整数和浮点数，其他则返回NaN(Not a Number)。 parseInt()支持进制参数，表示以何进制读取字符串，返回结果均为10进制数字。 parseInt() =&gt; NaN parseInt(&apos; &apos;) =&gt; NaN parseInt(null) =&gt; NaN parseInt(undefined) =&gt; NaN parseInt(false) =&gt; NaN parseInt(true) =&gt; NaN parseInt(NaN) =&gt; NaN parseInt(Infinity) =&gt; NaN parseInt(1) =&gt; 1 parseInt(&apos;1&apos;) =&gt; 1 parseInt(&apos; 1 &apos;) =&gt; 1 parseInt(&apos;1x&apos;) =&gt; 1 parseInt(-1.5) =&gt; -1 parseInt(&apos;-1.5&apos;) =&gt; -1 parseInt(&apos;-1.5x&apos;) =&gt; -1 parseInt(&apos;0xA&apos;) =&gt; 10 parseInt(&apos;0xAx&apos;) =&gt; 10 parseInt(&apos;010&apos;) =&gt; 10 parseInt(&apos;x&apos;) =&gt; NaN parseInt({}) =&gt; NaN parseInt(new Date()) =&gt; NaN parseInt(&apos;010&apos;) =&gt; 10 // 注意可能识别为8进制 parseInt(&apos;A&apos;, 16) =&gt; 10 // 以16进制读取，结果为10进制数字10 parseInt(&quot;012&quot;, 8) =&gt; 10 // 以8进制读取，结果为10进制数字10 parseInt(&apos;1000&apos;, 2) =&gt; 8 // 以2进制读取，结果为10进制数字8","text":"#1. 函数转换parseInt()和parseFloat()分别用来将数字型字符串或数字转换为整数和浮点数，其他则返回NaN(Not a Number)。 parseInt()支持进制参数，表示以何进制读取字符串，返回结果均为10进制数字。 parseInt() =&gt; NaN parseInt(&apos; &apos;) =&gt; NaN parseInt(null) =&gt; NaN parseInt(undefined) =&gt; NaN parseInt(false) =&gt; NaN parseInt(true) =&gt; NaN parseInt(NaN) =&gt; NaN parseInt(Infinity) =&gt; NaN parseInt(1) =&gt; 1 parseInt(&apos;1&apos;) =&gt; 1 parseInt(&apos; 1 &apos;) =&gt; 1 parseInt(&apos;1x&apos;) =&gt; 1 parseInt(-1.5) =&gt; -1 parseInt(&apos;-1.5&apos;) =&gt; -1 parseInt(&apos;-1.5x&apos;) =&gt; -1 parseInt(&apos;0xA&apos;) =&gt; 10 parseInt(&apos;0xAx&apos;) =&gt; 10 parseInt(&apos;010&apos;) =&gt; 10 parseInt(&apos;x&apos;) =&gt; NaN parseInt({}) =&gt; NaN parseInt(new Date()) =&gt; NaN parseInt(&apos;010&apos;) =&gt; 10 // 注意可能识别为8进制 parseInt(&apos;A&apos;, 16) =&gt; 10 // 以16进制读取，结果为10进制数字10 parseInt(&quot;012&quot;, 8) =&gt; 10 // 以8进制读取，结果为10进制数字10 parseInt(&apos;1000&apos;, 2) =&gt; 8 // 以2进制读取，结果为10进制数字8 建议所有转换均加上进制参数。 parseFloat()只能支持以10进制表示的浮点数，并且没有进制参数。 parseFloat() =&gt; NaN; parseFloat(&apos; &apos;) =&gt; NaN parseFloat(null) =&gt; NaN parseFloat(undefined) =&gt; NaN parseFloat(false) =&gt; NaN parseFloat(true) =&gt; NaN parseFloat(NaN) =&gt; NaN parseFloat(Infinity) =&gt; Infinity parseFloat(1) =&gt; 1 parseFloat(&apos;1&apos;) =&gt; 1 parseFloat(&apos; 1 &apos;) =&gt; 1 parseFloat(&apos;1x&apos;) =&gt; 1 parseFloat(-1.5) =&gt; -1.5 parseFloat(&apos;-1.5&apos;) =&gt; -1.5 parseFloat(&apos;-1.5x&apos;) =&gt; -1.5 parseFloat(&apos;0xA&apos;) =&gt; 0 parseFloat(&apos;0xAx&apos;) =&gt; 0 parseFloat(&apos;010&apos;) =&gt; 10 parseFloat({}) =&gt; NaN parseFloat(&apos;x&apos;) =&gt; NaN parseFloat(new Date()) =&gt; NaN parseInt()和parseFloat()能识别以数字开头的字符串。 #2. 强制类型转换 Number()函数用于将任何对象强制转换为数字，不可转换的对象将返回NaN。 Number() =&gt; 0 Number(&apos; &apos;) =&gt; 0 Number(null) =&gt; 0 Number(undefined) =&gt; NaN Number(false) =&gt; 0 Number(true) =&gt; 1 Number(NaN) =&gt; NaN Number(Infinity) =&gt; Infinity Number(1) =&gt; 1 Number(&apos;1&apos;) =&gt; 1 Number(&apos; 1 &apos;) =&gt; 1 Number(&apos;1x&apos;) =&gt; NaN Number(-1.5) =&gt; -1.5 Number(&apos;-1.5&apos;) =&gt; -1.5 Number(&apos;-1.5x&apos;) =&gt; NaN Number(&apos;0xA&apos;) =&gt; 10 Number(&apos;0xAx&apos;) =&gt; NaN Number(&apos;010&apos;) =&gt; 10 Number(&apos;x&apos;) =&gt; NaN Number({}) =&gt; NaN Number(new Date()) =&gt; Date.now() #3. 弱类型转换通过算数运算完成类型的自动转换，以下示例与x-0和+x的结果一致。 &apos;&apos; * 1 =&gt; 0 &apos; &apos; * 1 =&gt; 0 null * 1 =&gt; 0 undefined * 1 =&gt; NaN false * 1 =&gt; 0 true * 1 =&gt; 1 NaN * 1 =&gt; NaN Infinity * 1 =&gt; Infinity 1 * 1 =&gt; 1 &apos;1&apos; * 1 =&gt; 1 &apos; 1 &apos; * 1 =&gt; 1 &apos;1x&apos; * 1 =&gt; NaN -1.5 * 1 =&gt; -1.5 &apos;-1.5&apos; * 1 =&gt; -1.5 &apos;-1.5x&apos; * 1 =&gt; NaN &apos;0xA&apos; * 1 =&gt; 10 &apos;0xAx&apos; * 1 =&gt; NaN &apos;010&apos; * 1 =&gt; 10 &apos;x&apos; * 1 =&gt; NaN {} * 1 =&gt; NaN new Date() * 1 =&gt; Date.now() #4. 位运算位运算操作只返回整型结果，因此非常适合整型转换并且不需要判断NaN和Infinity的情况。 &apos;&apos; &gt;&gt; 0 =&gt; 0 &apos; &apos; &gt;&gt; 0 =&gt; 0 null &gt;&gt; 0 =&gt; 0 undefined &gt;&gt; 0 =&gt; 0 false &gt;&gt; 0 =&gt; 0 true &gt;&gt; 0 =&gt; 1 NaN &gt;&gt; 0 =&gt; 0 Infinity &gt;&gt; 0 =&gt; 0 1 &gt;&gt; 0 =&gt; 1 &apos;1&apos; &gt;&gt; 0 =&gt; 1 &apos; 1 &apos; &gt;&gt; 0 =&gt; 1 &apos;1x&apos; &gt;&gt; 0 =&gt; 0 -1.5 &gt;&gt; 0 =&gt; -1 &apos;-1.5&apos; &gt;&gt; 0 =&gt; -1 &apos;-1.5x&apos; &gt;&gt; 0 =&gt; 0 &apos;0xA&apos; &gt;&gt; 0 =&gt; 10 &apos;0xAx&apos; &gt;&gt; 0 =&gt; 0 &apos;010&apos; &gt;&gt; 0 =&gt; 10 &apos;x&apos; &gt;&gt; 0 =&gt; 0 {} &gt;&gt; 0 =&gt; 0 new Date() &gt;&gt; 0 =&gt; -2029... 类似的，也可以使用与运算&amp;0xFFFFFFFFFFFFF做整型转换。可以看出，以上几种方法都会自动忽略字符串的首尾空格，且能识别十六进制字符。对于NaN，可以使用||0来处理，如NaN || 0 =&gt; 0，不过需要注意Infinity的情况。几种方法各有利弊，本文也没有考虑性能的问题，在实际应用中需要根据具体需求选择合适的方法。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"学会JS的this这一篇就够了，根本不用记","slug":"javascriptThis","date":"2016-11-15T01:04:33.000Z","updated":"2016-11-15T01:10:18.679Z","comments":true,"path":"2016/11/15/javascriptThis/","link":"","permalink":"http://yoursite.com/2016/11/15/javascriptThis/","excerpt":"","text":"#以前看某本书上讲：掌握了JS中this的用法才算真正的跨过了JS的门槛我深以为是！但是JS的this却并不是那么简单的内容，许多同学都很困惑，也肯定有同学像我曾经一样查阅各种资料想知道How to understand this of javascript。很幸运的是，网上有非常非常多的文章关于this的，简直就是琳琅满目…曾经，我看到某些文章非常开心，因为他们讲得确实非常好，以至于我确信我已掌握了this的用法。然而可能是由于我太笨了，经常过一段时间就忘得一干二净了，这真的是一件很尴尬的事情……直到后来我仔细地琢磨又琢磨，终于感觉我可能以后不会再忘记了。所以想把我琢磨的内容和大家分享一下。 说到this，就不得不提到function，相信看过其它类似文章的同学也知道，正是由于调用function的对象不同，才导致了this的指向不同。所以以前老是去记忆每种调用function的情况所对应的this，因为情况有限而且很少，所以这当然是可行的——对于聪明人来说。所以我不得不思考另外一些方式来让我记住。 那么首先我们需要明确的一个事情是：function也是对象同时我们还需要明确的一个事情是：function执行时是在某个特定的上下文中执行的。那什么是上下文呢？打个比方，比如你练会了辟邪剑谱，那这时候你的掌门让你用辟邪剑谱砍人。如果仅仅是这样的话，你是没法完成这个任务的，因为你必须得知道要砍谁吧，其次去哪儿砍吧，那么是个地下通道还是一望无尽的大草原，要是地下通道你走路都困难，还怎么用辟邪剑谱呢对吧。这就是上下文，函数执行时它也需要一些额外的信息来支撑它的运行。那么既然function是对象的话，就会有方法。而function中最核心的方法是call方法。因此我们就从这儿入手。 #call方法先来看一下如何使用call方法: function say(content) { console.log(&quot;From &quot; + this + &quot;: Hello &quot;+ content); } say.call(&quot;Bob&quot;, &quot;World&quot;); //==&gt; From Bob: Hello World 接下来仔细分析一下call的用法：Step1: 把第二个到最后一个参数作为函数执行时要传入的参数Step2: 把函数执行时的this指向第一个参数Step3: 在上面这个特殊的上下文中执行函数上面例子中，我们通过call方法，让say函数执行时的this指向”Bob”，然后把”World”作为参数传进去，所以输出结果是可以预见的。js执行函数时会默认完成以上的步骤，你可以把直接调用函数理解为一种语法糖比如： function say(word) { console.log(world); } say(&quot;Hello world&quot;); say.call(window, &quot;Hello world&quot;); 以上可以把say(“Hello world”)看做是say.call(window,”Hello world”)的语法糖。 这个结论非常关键，所以以后每次看见functionName(xxx)的时候，你需要马上在脑海中把它替换为functionName.call(window,xxxx)，这对你理解this的指向非常重要。不过也有例外，在ES5的strict mode中call的第一个参数不是window而是undefined。之后的例子我假设总是不在strictmode下，但你需要记住strictmode有一点儿不同。对于匿名函数来说，上面的结论也是成立的 (function(name) { // })(&quot;aa&quot;); //等价于 (function(name) { // }).call(window, &quot;aa&quot;); 函数作为对象的方法被调用直接来看代码： var person = { name : &quot;caibirdme&quot;, run : function(time) { console.log(this.name + &quot;has been running for over &quot;+ time+ &quot; minutes&quot;); }}; person.run(30); //==&gt; caibirdme has been running for over 30 minutes//等价于 person.run.call(person, 30); // the same 你会发现这里call的第一个参数是person而不是window。当你明白了这两点，下意识地把函数调用翻译成foo.call()的形式，明确call的第一个参数，那基本上this的问题就难不住你了。还是来举几个例子吧 #例一： function hello(thing) { console.log(this + &quot; says hello &quot; + thing); } person = { name: &quot;caibirdme&quot; } person.hello = hello; person.hello(&quot;world&quot;) // 相当于执行 person.hello.call(person, &quot;world&quot;) hello(&quot;world&quot;) // 相当于执行 hello.call(window, &quot;world&quot;) #例二： var obj = { x: 20, f: function(){ console.log(this.x); } }; obj.f(); // obj.f.call(obj)//==&gt; 20 obj.innerobj = { x: 30, f: function(){ console.log(this.x); } } obj.innerobj.f(); // obj.innerobj.f.call(obj.innerobj)// ==&gt; 30 #例三： var x = 10; var obj = { x: 20, f: function(){ console.log(this.x); //this equals obj // ==&gt; 20 var foo = function(){ console.log(this.x); } foo(); // foo.call(window) //foo中this被指定为window，所以==&gt; 10 } }; obj.f(); // obj.f.call(obj)// ==&gt; 20 10 由例三引出一个非常common的问题，如果我想让foo输出20怎么办？这时候需要用到一点小技巧 #例四： var x = 10; var obj = { x: 20, f: function(){ console.log(this.x); var that = this; //使用that保留当前函数执行上下文的this var foo = function(){ console.log(that.x); } //此时foo函数中的this仍然指向window，但我们使用that取得obj foo(); // foo.call(window) } }; obj.f(); obj.f.call(obj)// ==&gt; 20 20 再来一个稍微难一点点的(但其实用call替换法一点儿也不难) #例五： var x = 10; var obj = { x: 20, f: function(){ console.log(this.x); } }; obj.f(); // obj.f.call(obj)// ==&gt; 20 var fOut = obj.f; fOut(); // fOut.call(window)//==&gt; 10 var obj2 = { x: 30, f: obj.f } obj2.f(); // obj2.f.call(obj2)//==&gt; 30 例五有些同学会可能出错的原因，是没有明确我上面说的：this是在执行是才会被确认的他可能会认为说obj.f那个函数定义在obj里面，那this就该指向obj。如果看完这篇文章你还这么想的话，我会觉得我的表达水平太失败了……用于构造函数先看一段代码： func person(name) { this.name = name;} var caibirdme = new person(&quot;deen&quot;); // caibirdme.name == deen 我上面也说了，函数在用作构造函数时同样可以用call方法去代替，那这里怎么代替呢？这里你又需要明确一点：new constrcut()是一种创建对象的语法糖它等价于 function person(name) { this.name = name; } var foo = new person(&quot;deen&quot;); //通过new创建了一个对象 //new是一种语法糖，new person等价于 var bar = (function(name) { var _newObj = { constructor : person, __proto__ : person.prototype, }; _newObj.constructor(name); // _newObj.constructor.call(_newObj, name) return _newObj; })(); So you can see……为什么new的时候this就指向新的对象了吧？通过我这篇文章，我希望学会通过把一个函数调用替换成funcName.call的形式，从而理解运行时上下文中this到底指向谁。总结来说就是下面两个等价变形： foo() ---&gt; foo.call(window) obj.foo() --&gt; obj.foo.call(obj) 只要理解以上两个变形，this就不再是问题啦！！希望我的这种方法对各位同学认识this有所帮助，不要再像我曾经一样掉入this的坑中，相关面试题也不再怕怕啦，哈哈。 （想了想，还是给朋友们说下我自己的理解吧，this：当前执行环境的上下文，call和apply：修改对象的上下文）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript常用API总结","slug":"jsapi","date":"2016-11-08T00:57:52.000Z","updated":"2016-11-08T01:24:26.835Z","comments":true,"path":"2016/11/08/jsapi/","link":"","permalink":"http://yoursite.com/2016/11/08/jsapi/","excerpt":"","text":"下面是我整理的一些JavaScript常用的API清单。 目录 元素查找 class操作 节点操作 属性操作 内容操作 css操作 位置大小 事件 DOM加载完毕 绑定上下文 去除空格 Ajax JSON处理 节点遍历 元素查找 // Node document.getElementById(id) // document.getElementById(&apos;test&apos;) document.querySelector(selectors) // document.querySelector(&apos;#test div&apos;) document.doctype document.documentElement document.head document.title document.body // NodeList document.getElementsByClassName(names) // document.getElementsByClassName(&apos;test&apos;) document.getElementsByName(name) // document.getElementsByName(&apos;demo&apos;) document.getElementsByTagName(name) // document.getElementsByTagName(&apos;div&apos;) document.getElementsByTagNameNS(namespace, name) // document.getElementsByTagNameNS(&apos;http://www.w3.org/1999/xhtml&apos;, &apos;div&apos;) document.querySelectorAll(selectors) // document.querySelectorAll(&apos;#test div&apos;) document.links document.scripts document.images document.embeds document.forms class操作 // ie8 // add class el.className += &apos; &apos; + className; // has class function hasClass(el,className){ return new RegExp(&apos;(^| )&apos; + className + &apos;( |$)&apos;, &apos;gi&apos;).test(el.className); } // toggle class function toggleClass(el,className){ var classes = el.className.split(&apos; &apos;); var existingIndex = -1; for (var i = classes.length; i--;) { if (classes[i] === className){ existingIndex = i; } } if (existingIndex &gt;= 0){ classes.splice(existingIndex, 1); } else{ classes.push(className); } el.className = classes.join(&apos; &apos;); } // remove class function remove(el,className){ el.className = el.className.replace(new RegExp(&apos;(^|\\\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\\\b|$)&apos;, &apos;gi&apos;), &apos; &apos;); } // ie 10 el.classList.add(className); // add class el.classList.remove(className); // remove class el.classList.contains(className); // has class el.classList.toggle(className); // toggle class #节点操作 // 创建 var el = document.createElement(name); // 复制 el.cloneNode(true); // 默认为false(克隆节点及其后代), true(克隆节点及其属性，以及后代) // 向节点添加最后一个子节点 parent.appendChild(el); // 在指定子节点之前插入新的子节点 parent.insertBefore(el, parent.childNodes[0]); // insertAdjacentHTML方法 el.insertAdjacentHTML(where, htmlString); el.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入 el.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入 el.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入 el.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入 // 父元素 el.parentNode // 删除节点 el.parentNode.removeChild(el); // 兄弟节点 ie9+ var siblings = Array.prototype.filter.call(el.parentNode.children, function(child){ return child !== el; }) // 下一个兄弟节点 // ie8 function nextElementSibling(el) { do { el = el.nextSibling; } while ( el &amp;&amp; el.nodeType !== 1 ); return el; } nextElementSibling(el); // ie9+ el.nextElementSibling; // 上一个兄弟节点 // ie8 function previousElementSibling(el) { do { el = el.previousSibling; } while ( el &amp;&amp; el.nodeType !== 1 ); return el; } previousElementSibling(el); // ie9+ el.previousElementSibling; // Children // ie8 var children = []; for (var i = el.children.length; i--;) { // Skip comment nodes on IE8 if (el.children[i].nodeType != 8) children.unshift(el.children[i]); } // ie9+ el.children #属性操作 // 获取属性值 el.getAttribute(&apos;alt&apos;); // 设置属性值 el.setAttribute(&apos;alt&apos;, &apos;图片描述&apos;); #内容操作 // 获取元素内容 el.innerHTML // 设置元素内容 el.innerHTML = string // 获取元素内容(包含元素自身) el.outerHTML // 设置元素内容(包含元素自身) el.outerHTML = string // 获取文本内容 // ie8 el.innerText // ie9+ el.textContent // 设置文本内容 // ie8 el.innerText = string // ie9+ el.textContent = string #CSS操作 // 获取css样式 // ie8 el.currentStyle[attrName] // ie9+ window.getComputedStyle(el)[attrName] // 伪类 window.getComputedStyle(el , &quot;:after&quot;)[attrName]; // 设置CSS样式 el.style.display = &apos;none&apos;; #位置大小 // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高 // top 元素上外边界距窗口最上面的距离 // right 元素右外边界距窗口最上面的距离 // bottom 元素下外边界距窗口最上面的距离 // left 元素左外边界距窗口最上面的距离 // width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) // 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return { top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft } // 元素自身宽(包含border,padding) el.offsetWidth // 元素自身高(包含border,padding) el.offsetHeight // 元素的左外边框至包含元素的左内边框之间的像素距离 el.offsetLeft // 元素的上外边框至包含元素的上内边框之间的像素距离 el.offsetTop //通常认为 &lt;html&gt; 元素是在 Web 浏览器的视口中滚动的元素（IE6 之前版本运行在混杂模式下时是 &lt;body&gt; 元素） //因此，带有垂直滚动条的页面总高度就是 document.documentElement.scrollHeight // 在没有滚动条的情况下，元素内容的总高度 scrollHeight // 在没有滚动条的情况下，元素内容的总宽度 scrollWidth // 被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置 scrollLeft // 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置 scrollTop // 视口大小 // ie9+ var pageWidth = window.innerWidth, pageHeight = window.innerHeight; if (typeof pageWidth != &quot;number&quot;){ // ie8 if (document.compatMode == &quot;CSS1Compat&quot;){ pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; } else { // ie6混杂模式 pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; } } #事件 // 绑定事件 // ie9+ el.addEventListener(eventName, handler , Booleans); // Booleans默认false(事件在冒泡阶段执行),true(事件在捕获阶段执行) // ie8 el.attachEvent(&apos;on&apos; + eventName, function(){ handler.call(el); }); // 移除事件 // ie9+ el.removeEventListener(eventName, handler); // ie8 el.detachEvent(&apos;on&apos; + eventName, handler); // 事件触发 if (document.createEvent) { // ie9+ var event = document.createEvent(&apos;HTMLEvents&apos;); event.initEvent(&apos;change&apos;, true, false); el.dispatchEvent(event); } else { // ie8 el.fireEvent(&apos;onchange&apos;); } // event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement; // 事件代理 ul.addEventListener(&apos;click&apos;, function(event) { if (event.target.tagName.toLowerCase() === &apos;li&apos;) { console.log(event.target.innerHTML) } }); #DOM加载完毕 function ready(fn) { if (document.readyState != &apos;loading&apos;){ // ie9+ document.addEventListener(&apos;DOMContentLoaded&apos;, fn); } else { // ie8 document.attachEvent(&apos;onreadystatechange&apos;, function() { if (document.readyState != &apos;loading&apos;){ fn(); } }); } } #绑定上下文 // ie8 fn.apply(context, arguments); // ie9+ fn.bind(context); 去除空格 // ie8 string.replace(/^\\s+|\\s+$/g, &apos;&apos;); // ie9+ string.trim(); ajax // GET var request = new XMLHttpRequest(); request.open(&apos;GET&apos;, &apos;user.php?fname=Bill&amp;lname=Gates&apos;, true); // false（同步） request.send(); // ie8 request.onreadystatechange = function() { if (this.readyState === 4) { if (this.status &gt;= 200 &amp;&amp; this.status &lt; 400) { // Success! var data = JSON.parse(this.responseText); } else { // 错误 } } }; // ie9+ request.onload = function() { if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) { // Success! var data = JSON.parse(request.responseText); } else { // 服务器返回出错 } }; request.onerror = function() { // 连接错误 }; // POST var request = new XMLHttpRequest(); request.open(&apos;POST&apos;, &apos;user.php&apos;, true); // false（同步） request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); request.send(dataString); #JSON处理 JSON.parse(string); JSON.String(Object) #节点遍历 function forEach( nodeList, callback ) { if(Array.prototype.forEach){ // ie9+ Array.prototype.forEach.call( nodeList, callback ); }else { // ie8 for (var i = 0; i &lt; nodeList.length; i++){ callback(nodeList[i], i); } } } forEach(document.querySelectorAll(selector),function(el, i){ })","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"javascript创建对象的7种模式","slug":"creatObject","date":"2016-11-07T01:16:06.000Z","updated":"2016-11-07T01:36:00.442Z","comments":true,"path":"2016/11/07/creatObject/","link":"","permalink":"http://yoursite.com/2016/11/07/creatObject/","excerpt":"#1）工厂模式这种模式抽象了创建具体对象的过程考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节 1 function createPerson(name, age, job){ 2 var o = new Object(); 3 o.name = name; 4 o.age = age; 5 o.job = job; 6 o.sayName = function(){ 7 alert(this.name); 8 }; 9 return o; 10 } 11 var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 12 var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 函数 createPerson() 能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型） 。随着 JavaScript的发展，又一个新模式出现了。","text":"#1）工厂模式这种模式抽象了创建具体对象的过程考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节 1 function createPerson(name, age, job){ 2 var o = new Object(); 3 o.name = name; 4 o.age = age; 5 o.job = job; 6 o.sayName = function(){ 7 alert(this.name); 8 }; 9 return o; 10 } 11 var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 12 var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 函数 createPerson() 能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型） 。随着 JavaScript的发展，又一个新模式出现了。 #2）构造函数模式ECMAScript 中的构造函数可用来创建特定类型的对象，例如Object 和 Array 这样的原生构造函数 1 function Person(name, age, job){ 2 this.name = name; 3 this.age = age; 4 this.job = job; 5 this.sayName = function(){ 6 alert(this.name); 7 }; 8 } 9 var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 10 var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 在这个例子中， Person() 函数取代了 createPerson() 函数。我们注意到， Person() 中的代码除了与 createPerson() 中相同的部分外，还存在以下不同之处： 没有显式地创建对象； 直接将属性和方法赋给了 this 对象； 没有 return 语句。要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4个步骤：(1) 创建一个新对象；(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；(3) 执行构造函数中的代码（为这个新对象添加属性） ；(4) 返回新对象。在前面例子的最后， person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 constructor （构造函数）属性，该属性指向 Person ，如下所示。 1 alert(person1.constructor == Person); //true 2 alert(person2.constructor == Person); //true 但是，提到检测对象类型，还是 instan-ceof 操作符要更可靠一些。 我们在这个例子中创建的所有对象既是 Object 的实例， 同时也是 Person的实例，这一点通过 instanceof 操作符可以得到验证。 1 alert(person1 instanceof Object); //true 2 alert(person1 instanceof Person); //true 3 alert(person2 instanceof Object); //true 4 alert(person2 instanceof Person); //true 构造函数的问题使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍person1 和 person2 都有一个名为 sayName() 的方法，但那两个方法不是同一个 Function 的实例 1 function Person(name, age, job){ 2 this.name = name; 3 this.age = age; 4 this.job = job; 5 this.sayName = new Function(&quot;alert(this.name)&quot;); // 与声明函数在逻辑上是等价的 6 } 以下代码可以证明这一点。 1 alert(person1.sayName == person2.sayName); //false 因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。 1 function Person(name, age, job){ 2 this.name = name; 3 this.age = age; 4 this.job = job; 5 this.sayName = sayName; 6 } 7 function sayName(){ 8 alert(this.name); 9 } 10 var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 11 var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); #3）原型模式我们创建的每个函数都有一个 prototype （原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中 1 function Person(){ 2 } 3 Person.prototype.name = &quot;Nicholas&quot;; 4 Person.prototype.age = 29; 5 Person.prototype.job = &quot;Software Engineer&quot;; 6 Person.prototype.sayName = function(){ 7 alert(this.name); 8 }; 9 var person1 = new Person(); 10 person1.sayName(); //&quot;Nicholas&quot; 11 var person2 = new Person(); 12 person2.sayName(); //&quot;Nicholas&quot; 13 alert(person1.sayName == person2.sayName); //true 但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1 和 person2 访问的都是同一组属性和同一个 sayName() 函数。 理解原型对象 只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说，Person.prototype. constructor 指向 Person 。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性） ，指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫 [[Prototype]] 。虽然在脚本中没有标准的方式访问 [[Prototype]] ，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性proto ；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用 person1.sayName() 。这是通过查找对象属性的过程来实现的。（属性-&gt;原型-&gt;原型…） 虽然在所有实现中都无法访问到 [[Prototype]] ，但可以通过 isPrototypeOf() 方法来确定对象之间是否存在这种关系。从本质上讲，如果 [[Prototype]] 指向调用 isPrototypeOf() 方法的对象（ Person.prototype ） ，那么这个方法就返回 true ，如下所示： 1 alert(Person.prototype.isPrototypeOf(person1)); //true 2 alert(Person.prototype.isPrototypeOf(person2)); //true ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf() ，在所有支持的实现中，这个方法返回 [[Prototype]] 的值。例如： 1 alert(Object.getPrototypeOf(person1) == Person.prototype); //true 2 alert(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot; 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为 null ，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性 使用 hasOwnProperty() 方法可以检测一个属性是存在于实例中， 还是存在于原型中。这个方法 （不要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true 。 1 function Person(){ 2 } 3 Person.prototype.name = &quot;Nicholas&quot;; 4 Person.prototype.age = 29; 5 Person.prototype.job = &quot;Software Engineer&quot;; 6 Person.prototype.sayName = function(){ 7 alert(this.name); 8 }; 9 10 var person1 = new Person(); 11 var person2 = new Person(); 12 alert(person1.hasOwnProperty(&quot;name&quot;)); // 属性中没有 返回false 13 person1.name = &quot;Greg&quot;; 14 alert(person1.name); // &quot;Greg&quot;——来自实例 15 alert(person1.hasOwnProperty(&quot;name&quot;)); //true 16 alert(person2.name); // &quot;Nicholas&quot;——来自原型 17 alert(person2.hasOwnProperty(&quot;name&quot;)); //false 18 delete person1.name; 19 alert(person1.name); //&quot;Nicholas&quot;——来自原型 20 alert(person1.hasOwnProperty(&quot;name&quot;)); //false 原型与 in 操作符有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时， in 操作符会在通过对象能够访问给定属性时返回 true ，无论该属性存在于实例中还是原型中。 1 function Person(){ 2 } 3 Person.prototype.name = &quot;Nicholas&quot;; 4 Person.prototype.age = 29; 5 Person.prototype.job = &quot;Software Engineer&quot;; 6 Person.prototype.sayName = function(){ 7 alert(this.name); 8 }; 9 10 var person1 = new Person(); 11 var person2 = new Person(); 12 alert(person1.hasOwnProperty(&quot;name&quot;)); //false 13 alert(&quot;name&quot; in person1); //true 14 person1.name = &quot;Greg&quot;; 15 alert(person1.name); //&quot;Greg&quot; ——来自实例 16 alert(person1.hasOwnProperty(&quot;name&quot;)); //true 17 alert(&quot;name&quot; in person1); //true 18 alert(person2.name); //&quot;Nicholas&quot; ——来自原型 19 alert(person2.hasOwnProperty(&quot;name&quot;)); //false 20 alert(&quot;name&quot; in person2); //true 21 delete person1.name; 22 alert(person1.name); //&quot;Nicholas&quot; ——来自原型 23 alert(person1.hasOwnProperty(&quot;name&quot;)); //false 24 alert(&quot;name&quot; in person1); //true 结合hasOwnProperty 判断一个属性是否存在切存在于原型中 1 function hasPrototypeProperty(object, name){ 2 return !object.hasOwnProperty(name) &amp;&amp; (name in object); 3 } 更简单的原型语法 1 function Person(){ 2 } 3 Person.prototype = { 4 name : &quot;Nicholas&quot;, 5 age : 29, 6 job: &quot;Software Engineer&quot;, 7 sayName : function () { 8 alert(this.name); 9 } 10 }; 在上面的代码中，我们将 Person.prototype 设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外： constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新对象的 constructor 属性 （指向 Object 构造函数） ， 不再指向 Person 函数。此时， 尽管 instanceof操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了，如下所示。 1 var friend = new Person(); 2 alert(friend instanceof Object); //true 3 alert(friend instanceof Person); //true 4 alert(friend.constructor == Person); //false 5 alert(friend.constructor == Object); //true 解决办法很简单，手动指定 1 function Person(){ 2 } 3 Person.prototype = { 4 constructor : Person, 5 name : &quot;Nicholas&quot;, 6 age : 29, 7 job: &quot;Software Engineer&quot;, 8 sayName : function () { 9 alert(this.name); 10 } 11 }; 注意，以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。默认情况下，原生的 constructor 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 Object.defineProperty() 。 // 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器 1 Object.defineProperty(Person.prototype, &quot;constructor&quot;, { 2 enumerable: false, 3 value: Person 4 }); 原型的动态性由于在原型中查找值的过程是一次搜索， 因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此 1 var friend = new Person(); 2 Person.prototype.sayHi = function(){ 3 alert(&quot;hi&quot;); 4 }; 5 friend.sayHi(); //&quot;hi&quot;（没有问题！） 但是，如果我们使用对象字面量的方式修改Person的原型，此时的Person.protptype指向的是一个新对象我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]] 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。 1 function Person(){ 2 } 3 var friend = new Person(); 4 Person.prototype = { 5 constructor: Person, 6 name : &quot;Nicholas&quot;, 7 age : 29, 8 job : &quot;Software Engineer&quot;, 9 sayName : function () { 10 alert(this.name); 11 } 12 }; 13 friend.sayName(); //error 过程如下图所示 原生对象的原型原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（ Object 、 Array 、 String ，等等）都在其构造函数的原型上定义了方法。例如，在 Array.prototype 中可以找到 sort() 方法，而在 String.prototype 中可以找到substring() 方法 1 alert(typeof Array.prototype.sort); //&quot;function&quot; 2 alert(typeof String.prototype.substring); //&quot;function&quot; 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型String 添加了一个名为 startsWith() 的方法。 1 String.prototype.startsWith = function (text) { 2 return this.indexOf(text) == 0; 3 }; 4 var msg = &quot;Hello world!&quot;; 5 alert(msg.startsWith(&quot;Hello&quot;)); //true 原型对象的问题原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。 虽然这会在某种程度上带来一些不方便， 但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。尤其对于包含引用类型值的属性来说（基本值还可以隐藏） 1 function Person(){ 2 } 3 Person.prototype = { 4 constructor: Person, 5 name : &quot;Nicholas&quot;, 6 age : 29, 7 job : &quot;Software Engineer&quot;, 8 friends : [&quot;Shelby&quot;, &quot;Court&quot;], 9 sayName : function () { 10 alert(this.name); 11 } 12 }; 13 var person1 = new Person(); 14 var person2 = new Person(); 15 person1.friends.push(&quot;Van&quot;); 16 alert(person1.friends); //&quot;Shelby,Court,Van&quot; 17 alert(person2.friends); //&quot;Shelby,Court,Van&quot; 18 alert(person1.friends === person2.friends); //true #4）组合使用构造函数模式和原型模式创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。 1 function Person(name, age, job){ 2 this.name = name; 3 this.age = age; 4 this.job = job; 5 this.friends = [&quot;Shelby&quot;, &quot;Court&quot;]; 6 } 7 Person.prototype = { 8 constructor : Person, 9 sayName : function(){ 10 alert(this.name); 11 } 12 } 13 var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 14 var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 15 person1.friends.push(&quot;Van&quot;); 16 alert(person1.friends); //&quot;Shelby,Count,Van&quot; 17 alert(person2.friends); //&quot;Shelby,Count&quot; 18 alert(person1.friends === person2.friends); //false 19 alert(person1.sayName === person2.sayName); //true 是目前在 ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法 #5）动态原型模式动态原型模式致力于解决这样一个问题，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下） ，又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。 1 function Person(name, age, job){ 2 //属性 3 this.name = name; 4 this.age = age; 5 this.job = job; 6 // 方法 7 if (typeof this.sayName != &quot;function&quot;){ 8 Person.prototype.sayName = function(){ 9 alert(this.name); 10 }; 11 } 12 } 13 var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 14 friend.sayName(); 注意构造函数代码中加粗的部分。这里只在 sayName() 方法不存在的情况下，才会将它添加到原型中。使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。 #6）寄生构造函数模式通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。 1 function Person(name, age, job){ 2 var o = new Object(); 3 o.name = name; 4 o.age = age; 5 o.job = job; 6 o.sayName = function(){ 7 alert(this.name); 8 }; 9 return o; 10 } 11 var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 12 friend.sayName(); //&quot;Nicholas&quot; 除了使用 new 操作符并把使用的包装函数叫做构造函数之外， 这个模式跟工厂模式其实是一模一样的。工厂模式为 1 function createPerson(name, age, job){ 2 var o = new Object(); 3 o.name = name; 4 o.age = age; 5 o.job = job; 6 o.sayName = function(){ 7 alert(this.name); 8 }; 9 return o; 10 } 11 var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 12 var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;); 关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。 由于存在上述问题， 我们建议在可以使用其他模式的情况下，不要使用这种模式。 #7）稳妥构造函数模式所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在一些安全的环境中 （这些环境中会禁止使用 this 和 new ） ， 或者在防止数据被其他应用程序 （如 Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this ；二是不使用 new 操作符调用构造函数。按照稳妥构造函数的要求，可以将前面的 Person 构造函数重写如下。 1 function Person(name, age, job){ 2 //创建要返回的对象 3 var o = new Object(); 4 //可以在这里定义私有变量和函数 5 //添加方法 6 o.sayName = function(){ 7 alert(name); 8 }; 9 //返回对象 10 return o; 11 } 12 var friend = Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); 13 friend.sayName(); //&quot;Nicholas&quot; 注意， 在以这种模式创建的对象中， 除了使用 sayName() 方法之外， 没有其他办法访问 name 的值。与寄生构造函数模式类似， 使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有意义。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"ES6 你可能不知道的事 - 基础篇","slug":"es6Basics","date":"2016-10-21T01:12:07.000Z","updated":"2016-10-21T01:29:56.060Z","comments":true,"path":"2016/10/21/es6Basics/","link":"","permalink":"http://yoursite.com/2016/10/21/es6Basics/","excerpt":"#序 ES6，或许应该叫 ES2015（2015 年 6 月正式发布），对于大多数前端同学都不陌生。 首先这篇文章不是工具书，不会去过多谈概念，而是想聊聊关于每个特性 你可能不知道的事，希望能为各位同学 正确使用 ES6，提供一些指导。 对于 ES6，有些同学已经在项目中有过深入使用了，有些则刚刚开始认识他，但不论你是属于哪一类，相信这篇文章都有适合你的部分。针对文章中的问题或不同意见，欢迎随时拍砖、指正。 #正文 Let + Const 这个大概是开始了解 ES6 后，我们第一个感觉自己完全明白并兴致勃勃的开始使用的特性。 以如下方式使用的同学请举下手？ 1 // 定义常量 2 const REG_GET_INPUT = /^\\d{1,3}$/; 3 4 // 定义配置项 5 let config = { 6 isDev : false, 7 pubDir: &apos;./admin/&apos; 8 } 9 10 // 引入 gulp 11 let gulp = require(&apos;gulp&apos;); 12 13 // 引入gulp相关插件 14 let concat = require(&apos;gulp-concat&apos;); 15 let uglify = require(&apos;gulp-uglify&apos;); 16 let cssnano = require(&apos;gulp-cssnano&apos;);","text":"#序 ES6，或许应该叫 ES2015（2015 年 6 月正式发布），对于大多数前端同学都不陌生。 首先这篇文章不是工具书，不会去过多谈概念，而是想聊聊关于每个特性 你可能不知道的事，希望能为各位同学 正确使用 ES6，提供一些指导。 对于 ES6，有些同学已经在项目中有过深入使用了，有些则刚刚开始认识他，但不论你是属于哪一类，相信这篇文章都有适合你的部分。针对文章中的问题或不同意见，欢迎随时拍砖、指正。 #正文 Let + Const 这个大概是开始了解 ES6 后，我们第一个感觉自己完全明白并兴致勃勃的开始使用的特性。 以如下方式使用的同学请举下手？ 1 // 定义常量 2 const REG_GET_INPUT = /^\\d{1,3}$/; 3 4 // 定义配置项 5 let config = { 6 isDev : false, 7 pubDir: &apos;./admin/&apos; 8 } 9 10 // 引入 gulp 11 let gulp = require(&apos;gulp&apos;); 12 13 // 引入gulp相关插件 14 let concat = require(&apos;gulp-concat&apos;); 15 let uglify = require(&apos;gulp-uglify&apos;); 16 let cssnano = require(&apos;gulp-cssnano&apos;); 很多人看完概念之后，第一印象都是：“const 是表示不可变的值，而 let 则是用来替换原来的 var 的。” 所以就会出现上面代码中的样子；一段代码中出现大量的 let，只有部分常量用 const 去做定义，这样的使用方式是错误的。 你可能不知道的事 const 的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性。 所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以const做定义。反之就 let 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。 猜想：就执行效率而言，const 由于不可以重新赋值的特性，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率。 所以上面代码中，所有使用 let 的部分，其实都应该是用 const 的。 Template Strings（字符串模板） 字符串模板是我刚接触ES6时最喜欢的特性之一，他语法简洁，语义明确，而且很好的解决了之前字符串拼接麻烦的问题。 因为他并不是 “必须” 的，而且原有的字符串拼接思维根深蒂固，导致我们很容易忽视掉他。 使用实例 我们先来看看他的一般使用场景： 1 const start = &apos;hi all&apos;; 2 3 const getName = () =&gt; { 4 return &apos;jelly&apos;; 5 }; 6 7 const conf = { 8 fav: &apos;Coding&apos; 9 }; 10 11 // 模板 12 const msg = `${start}, my name is ${getName()}, ${conf.fav} is my favourite`; 你可能不知道的事 1 // 1. 与引号混用 2 const wantToSay = `I&apos;m a &quot;tbfed&quot;`; 3 4 // 2. 支持多行文本 5 const slogan = 6 &apos; 7 I have a dream today! 8 &apos;; 9 10 // 比较适合写HTML 11 const resultTpl = 12 &apos; 13 &lt;section&gt; 14 &lt;div&gt;...&lt;/div&gt; 15 &lt;/section&gt; 16 &apos;; 17 #Enhanced Object Literals（增强的对象字面量） 增强的对象字面量是 ES6 中的升华功能，他设计了很多简写，这些简写不但保留了明确的语义，还减少了我们多余的代码量。 当他的使用成为一个习惯时，我们会看到自己代码变得更为优雅。 你可能不知道的事 1 const _bookNum = 4; 2 3 const basicConfig = { 4 level: 5 5 } 6 7 const config = { 8 // 直接指定原型对象 9 __proto__: basicConfig, 10 11 // 属性简写 12 _bookNum, 13 14 // 方法简写 15 getBookNum() { 16 return this.bookNum; 17 } 18 } #Arrows and Lexical This（箭头函数） 箭头函数是ES6中的一个新的语法特性，他的用法简单，形态优雅，备受人们青睐。 大多数同学初识这个特性时，更多的仅仅用它作为函数定义的简写，这其实就有些屈才了。 1 // 未使用箭头函数的写法 2 { 3 ... 4 5 addOptions: function (options) { 6 7 var self = this; 8 9 options.forEach(function(name, opts){ 10 11 self[name] = self.addChild(name, opts); 12 13 }); 14 15 } 16 } 17 18 // 使用箭头函数后的写法 19 { 20 ... 21 22 addOptions: function (options) { 23 24 options.forEach((name, opts) =&gt; { 25 26 this[name] = this.addChild(name, opts); 27 28 }); 29 30 } 31 } 可以注意到上下两段代码的区别。 在未使用箭头函数前，我们在过程函数中使用父级 this，需要将其显式缓存到另一个中间变量中，因为过程函数有独立的 this 变量，会覆盖父级；使用箭头函数后，不但简写了一个过程函数（ forEach 的参数），还省略掉了 this 的中间变量的定义。 原因：箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。 插播：原来我们定义这个中间变量还有一个有趣的现象，就是明明千奇百怪，例如 self, that, me, _that, _me, Self…，快站出来说说你用过哪个，还是哪几个~ 当然，从这块我们也可以看出，箭头函数是无法替代全部 function 的使用场景的，例如我们需要有独立 this 的函数。 你可能不知道的事 箭头函数不但没有独立 this，他也没有独立的 arguments，所以如果需要取不定参的时候，要么使用 function，要么用 ES6 的另一个新特性 rest（具体在 rest 中会有详解）。 箭头函数语法很灵活，在只有一个参数或者只有一句表达式做方法体时，可以省略相应括号。 1 // 完整写法 2 const getOptions = (name, key) =&gt; { 3 ... 4 } 5 6 // 省略参数括号 7 const getOptions = key =&gt; { 8 ... 9 } 10 11 // 省略参数和方法体括号 12 const getOptions = key =&gt; console.log(key); 13 14 // 无参数或方法体，括号不能省略 15 const noop = () =&gt; {}; 16 有个简单小栗子，这一灵活的语法在写连续的Promise链式调用时，可以使代码更加优雅 1 gitPromise 2 .then(() =&gt; git.add()) 3 .then(() =&gt; git.commit()) 4 .then(() =&gt; git.log()) 5 .then((msg) =&gt; { 6 ... 7 }) 8 .then(() =&gt; git.push()) 9 .catch((err) =&gt; { 10 utils.error(err); 11 }); #Destructuring（解构） 解构这个特性可以简单解读为分别定义，用于一次定义多个变量，常常用于分解方法返回对象为多个变量，分别使用。 使用过ES6的同学应该或多或少接触过这个特性，但是你可能不知道它如下几个用法： 你可能不知道的事 1 const bookSet = [&apos;UED&apos;, &apos;TB fed&apos;, &apos;Not find&apos;]; 2 const bookCollection = () =&gt; { 3 return {book1: &apos;UED&apos;, book2: &apos;TB fed&apos;}; 4 }; 5 6 // 1. 解构也可以设置默认值 7 const {book1, book3 = &apos;Not find&apos;} = bookCollection(); 8 9 // 2. 解构数组时候是可以跳过其中某几项的 10 const [book1,,book3] = bookSet; // book1 = &apos;UED&apos;, book3 = &apos;Not find&apos; 11 12 // 3. 解构可以取到指定对象的任何属性，包括它包含的方法 13 const {length: setLength} = bookSet; // setLength = 3 #Rest + Spread Rest 和 Spread 主要是应用 … 运算符，完成值的聚合和分解。 你可能不知道的事 1 // 1. rest 得到的是一个真正的数组而不是一个伪数组 2 const getOptions = function(...args){ 3 console.log(args.join); // function 4 }; 5 6 // 2. rest 可以配合箭头函数使用，达到取得所有参数的目的 7 const getOptions = (...args) =&gt; { 8 console.log(args); // array 9 }; 10 11 // 3. spread 可以用于解构时，聚合所得的值 12 const [opt1, ...opts] = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;]; 13 14 // 4. spread 可以用于数组定义 15 const opts = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;]; 16 const config = [&apos;other&apos;, ...opts]; #Classes ES6 中实现的一个语法糖，用于简化基于原型集成实现类定义的场景。 虽然有很多人不太喜欢这个特性，认为它作为一个简单增强扩展，并没有其他语言 class 应有的特点。 但是就我自己观点来看，还是感觉这样一种写法确实比原有的原型继承的写法语义更清晰、明确，而且语法更简单。 同样，可能有些用法是你之前容易忽略掉的，在此做个补充。 你可能不知道的事 1 // 1. 静态变量 2 // ES6 的类定义实现了静态方法的定义，但静态变量呢？ 3 // 可以用如下方式实现: 4 class TbFedMembers{ 5 static get HuaChen(){ 6 return &apos;jelly&apos;; 7 } 8 } 9 TbFedMembers.HuaChen; // &quot;化辰&quot; 10 11 // 2. 私有属性（私有属性有多种实现方式，只谈及其中一种） 12 // 闭包 13 const TbFedMembers = (() =&gt; { 14 const HuaChen = &apos;jelly&apos;; 15 16 return class{ 17 getOneMemberName(){ 18 return HuaChen; 19 } 20 }; 21 })(); #Promises Promise 不只是一个对象、一个语法，他更是一种异步编程方式的变化 相信使用过 ES6 的同学都已经开始尝试了 Promise，甚至在不支持ES6的时候，已经开始使用一些基于 Promise 思想的开源框架。 那么我们之前用 Promise 究竟用的对么？有什么需要注意的点呢？ 你可能不知道的事 1 // 1. 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用 2 // Promise.all 3 Promise 4 .all([jsBuildPromise, cssBuildPromise]) 5 .then(() =&gt; { 6 ... 7 }); 8 9 // chain 10 jsBuildPromise 11 .then(() =&gt; cssBuildPromise) 12 .then(() =&gt; { 13 ... 14 }); 15 16 17 // 2. Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行 18 gitPromise 19 .then(() =&gt; git.add()) // 正确，箭头函数简写 20 .then(() =&gt; { 21 git.commit(); // 错误，函数返回 undefined，会立即执行下一过程 22 }) 23 .then(() =&gt; { 24 return git.log(); // 正确 25 }); 26 27 28 // 3. Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行 29 new Promise(() =&gt; { 30 f; // not define error ! 31 }) 32 .catch((err) =&gt; { 33 console.log(err) // show &apos;f is not define&apos; 34 }); 35 console.log(&apos;error test&apos;); // 此行可以被正常执行 #结语 基础篇主要是讲了我们最常用的一些特性，后续如果大家感兴趣，还可以再来个 “进阶篇”，最后，希望文章中的部分内容可以对大家理解和使用 ES6 有所帮助。 转自：http://taobaofed.org/blog/2016/07/22/es6-basics/","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"深入理解定时器：setTimeout与setInterval","slug":"timer","date":"2016-10-21T01:01:55.000Z","updated":"2016-10-21T01:30:22.180Z","comments":true,"path":"2016/10/21/timer/","link":"","permalink":"http://yoursite.com/2016/10/21/timer/","excerpt":"#setTimeout setTimeout()方法用于在指定的毫秒数后调用函数或计算表达式。 1 setTimeout(function(){ 2 console.log(&apos;hello&apos;) 3 },1000) 这段代码将会在1s后在控制台出‘hello’，setTimeout只运行一次，也就是说设定的时间到后就触发运行指定代码，运行完后即结束。 setTimeout创建的定时器会返回一个ID值，利用这个ID值配合cleartimeout可以取消要延迟执行的代码块： 1 var t =setTimeout(function(){ 2 alert(&apos;hello&apos;) 3 },1000) 4 clearTimeout(t) 5 setInterval setInterval()与setTimeout()相同，区别在于后者是重复性的检测和执行： 1 var t = setInterval(function(){ 2 console.log(&apos;hello&apos;) 3 },1000) 上面的代码每隔1s在控制台输出‘ hello’ setInterval创建的定时器可以使用clearInterval取消","text":"#setTimeout setTimeout()方法用于在指定的毫秒数后调用函数或计算表达式。 1 setTimeout(function(){ 2 console.log(&apos;hello&apos;) 3 },1000) 这段代码将会在1s后在控制台出‘hello’，setTimeout只运行一次，也就是说设定的时间到后就触发运行指定代码，运行完后即结束。 setTimeout创建的定时器会返回一个ID值，利用这个ID值配合cleartimeout可以取消要延迟执行的代码块： 1 var t =setTimeout(function(){ 2 alert(&apos;hello&apos;) 3 },1000) 4 clearTimeout(t) 5 setInterval setInterval()与setTimeout()相同，区别在于后者是重复性的检测和执行： 1 var t = setInterval(function(){ 2 console.log(&apos;hello&apos;) 3 },1000) 上面的代码每隔1s在控制台输出‘ hello’ setInterval创建的定时器可以使用clearInterval取消 // …clearInterval(t)定时器的问题 setTimeout的问题在于它并不是精准的，例如使用setTimeout设定一个任务在10ms后执行，但是在9ms后，有一个任务占用了5ms的cpu时间片，再次轮到定时器执行时，时间已经过期了4ms，那么是不是说setInterval就是准确的呢？ 然而并不是，setInterval存在两个问题： 时间间隔可能会跳过时间间隔可能小于定时器设定的时间请看以下代码 1 function click() { 2 // code block1... 3 setInterval(function() { 4 // process ... 5 }, 200); 6 // code block2 7 } 我们假设通过一个click, 触发了setInterval以实现每隔一个时间段执行process代码，在205ms时执行setInterval, 以此为一个时间点, 在205ms时插入process代码, process代码开始执行, 然而process代码执行的时间超过了接下来一个插入时间点405ms, 这样代码队列后又插入了一份process代码, process继续执行着, 而且超过了605ms这个插入时间点。 下面问题来了, 由于代码队列中已经有了一份未执行的process代码(405m时插入的), 所以605ms这个插入时间点将会被跳过, 因为js引擎只允许有一份未执行的process代码 为了避免这种情况可以使用setTimeout递归调用代码如下: 1 setTimeout(function(){ 2 // processing 3 setTimeout(arguments.callee, interval); 4 }, interval); 每次函数执行的时候都会创建一个新的定时器，第二个setTimeout调用使用了arguments.callee来获取对当前执行的函数的引用，并为其设置另外一个定时器。这样做是为了在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔，也保证了在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"jQuery的14个数据类型","slug":"datatype","date":"2016-10-18T03:52:23.000Z","updated":"2016-10-18T04:56:49.905Z","comments":true,"path":"2016/10/18/datatype/","link":"","permalink":"http://yoursite.com/2016/10/18/datatype/","excerpt":"jQuery除了包含原生JS中的内置数据类型(built-in datatype)，还包括一些扩展的数据类型(virtual types)，如Selectors、Events等。 #1. String String最常见，几乎任何一门高级编程语言和脚本语言中都支持，比如”Hello world!”即字符串。字符串的类型为string。比如 var typeOfStr = typeof &quot;hello world&quot;;//typeOfStr为“string&quot; 1.1 String内置方法 &quot;hello&quot;.charAt(0) // &quot;h&quot; &quot;hello&quot;.toUpperCase() // &quot;HELLO&quot; &quot;Hello&quot;.toLowerCase() // &quot;hello&quot; &quot;hello&quot;.replace(/e|o/g, &quot;x&quot;) // &quot;hxllx&quot; &quot;1,2,3&quot;.split(&quot;,&quot;) // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] 1.2 length属性：返回字符长度，比如”hello”.length返回5 1.3 字符串转换为Boolean： 一个空字符串（””）默认为false，而一个非空字符串为true（比如”hello”）。","text":"jQuery除了包含原生JS中的内置数据类型(built-in datatype)，还包括一些扩展的数据类型(virtual types)，如Selectors、Events等。 #1. String String最常见，几乎任何一门高级编程语言和脚本语言中都支持，比如”Hello world!”即字符串。字符串的类型为string。比如 var typeOfStr = typeof &quot;hello world&quot;;//typeOfStr为“string&quot; 1.1 String内置方法 &quot;hello&quot;.charAt(0) // &quot;h&quot; &quot;hello&quot;.toUpperCase() // &quot;HELLO&quot; &quot;Hello&quot;.toLowerCase() // &quot;hello&quot; &quot;hello&quot;.replace(/e|o/g, &quot;x&quot;) // &quot;hxllx&quot; &quot;1,2,3&quot;.split(&quot;,&quot;) // [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] 1.2 length属性：返回字符长度，比如”hello”.length返回5 1.3 字符串转换为Boolean： 一个空字符串（””）默认为false，而一个非空字符串为true（比如”hello”）。 #2. Number 数字类型，比如3.1415926或者1、2、3… typeof 3.1415926 //返回的是&quot;number&quot; 2.1 Number转换为Boolean： 如果一个Number值为0，则默认为false，否则为true。 2.2 由于Number是采用双精度浮点数实现的，所以下面这种情况是合理的： 0.1 + 0.2 // 0.30000000000000004 #3. Math 下面的方法与Java中的Math类的静态方法类似。 Math.PI // 3.141592653589793 Math.cos(Math.PI) // -1 3.1 将字符串化为数字：parseInt和parseFloat方法： parseInt(&quot;123&quot;) = 123 (采用十进制转换) parseInt(&quot;010&quot;) = 8 (采用八进制转换) parseInt(&quot;0xCAFE&quot;) = 51966 (采用十六进制转换) parseInt(&quot;010&quot;, 10) = 10 (指定用10进制转换) parseInt(&quot;11&quot;, 2) = 3 (指定用二进制转换) parseFloat(&quot;10.10&quot;) = 10.1 3.2 数字到字符串 当将Number粘到（append）字符串后的时候，将得到字符串。 &quot;&quot; + 1 + 2; // &quot;12&quot; &quot;&quot; + (1 + 2); // &quot;3&quot; &quot;&quot; + 0.0000001; // &quot;1e-7&quot; 或者用强制类型转换： String(1) + String(2); //&quot;12&quot; String(1 + 2); //&quot;3&quot; #4. NaN 和 Infinity 如果对一个非数字字符串调用parseInt方法，将返回NaN(Not a Number)，NaN常用来检测一个变量是否数字类型，如下： isNaN(parseInt(&quot;hello&quot;, 10)) // true //Infinity表示数值无穷大或无穷小，比如1 / 0 // Infinity。 //对NaN和Infinity调用typeof运算符都返回&quot;numuber&quot;。 //另外 NaN==NaN 返回false，但是 Infinity==Infinity 返回true。 #5. Integer 和 Float分为表示整型和浮点型。 http://w去ww.cn掉blogs.c中文om/roucheng/ #6. BOOLEAN布尔类型，true或者false。 #7. OBJECTJavaScript中的一切皆对象。对一个对象进行typeof运算返回 “object”。 var x = {}; var y = { name: &quot;Pete&quot;, age: 15 }; 对于上面的y对象，可以采用圆点获取属性值，比如y.name返回”Pete”，y.age返回15 7.1 Array Notation（数组访问方式访问对象） var operations = { increase: &quot;++&quot;, decrease: &quot;--&quot; } var operation = &quot;increase&quot;; operations[operation] // &quot;++&quot;; operations[&quot;multiply&quot;] = &quot;*&quot;; // &quot;*&quot; //上面operations[&quot;multiply&quot;]=&quot;*&quot;; 往operations对象中添加了一个key-value对。 7.2 对象循环访问：for-in var obj = { name: &quot;Pete&quot;, age: 15}; for(key in obj) { alert(&quot;key is &quot;+[key]+&quot;, value is &quot;+obj[key]); } 7.3 任何对象不管有无属性和值，都默认为true 7.4 对象的Prototype属性 jQuery中用fn（Prototype的别名）动态为jQuery Instances添加对象（函数） var form = $(&quot;#myform&quot;); form.clearForm; // undefined form.fn.clearForm = function() { return this.find(&quot;:input&quot;).each(function() { this.value = &quot;&quot;; }).end(); }; form.clearForm() // works for all instances of jQuery objects, because the new method was added #8. OPTIONS几乎所有的jQuery插件都提供了一个基于OPTIONS的API，OPTIONS是JS对象，意味着该对象以及它的属性都是optional（可选的）。允许customization。 比如采用Ajax方式提交表单， $(&quot;#myform&quot;).ajaxForm();//默认采用Form的Action属性值作为Ajax-URL，Method值作为提交类型(GET/POST) $(&quot;#myform&quot;).ajaxForm({ url: &quot;mypage.php&quot;, type: &quot;POST&quot; });//则覆盖了提交到的URL和提交类型 #9. ARRAY var arr = [1, 2, 3]; ARRAY是可变的lists。ARRAY也是对象。读取或设置ARRAY中元素的值，采用这种方式： var val = arr[0];//val为1 arr[2] = 4;//现在arr第三个元素为4 9.1 数组循环（遍历） for (var i = 0; i &lt; a.length; i++) { // Do something with a[i] } 但是当考虑性能时，则最好只读一次length属性，如下： for (var i = 0, j = a.length; i &lt; j; i++) { // Do something with a[i] } jQuery提供了each方法遍历数组： var x = [1, 2, 3]; $.each(x, function(index, value) { console.log(&quot;index&quot;, index, &quot;value&quot;, value); }); 9.2 对数组调用push方法意味着将一个元素添加到数组末尾，比如 x.push(5); 和 x.[x.length] = 5; 等价 9.3 数组其他内置方法： var x = [0, 3, 1, 2]; x.reverse() // [2, 1, 3, 0] x.join(&quot; – &quot;) // &quot;2 - 1 - 3 - 0&quot; x.pop() // [2, 1, 3] x.unshift(-1) // [-1, 2, 1, 3] x.shift() // [2, 1, 3] x.sort() // [1, 2, 3] x.splice(1, 2) // 用于插入、删除或替换数组元素，这里为删除从index=1开始的2个元素 9.4 数组为对象，所以始终为true #10. MAP The map type is used by the AJAX function to hold the data of a request. This type could be a string, an array, a jQuery object with form elements or an object with key/value pairs. In the last case, it is possible to assign multiple values to one key by assigning an array. As below: {&apos;key[]&apos;:[&apos;valuea&apos;,&apos;valueb&apos;]} #11. FUNCTION:匿名和有名两种 11.1 Context、Call和Apply In JavaScript, the variable “this” always refers to the current context. $(document).ready(function() { // this refers to window.document}); $(&quot;a&quot;).click(function() { // this refers to an anchor DOM element }); #12. SELECTOR There are lot of plugins that leverage jQuery’s selectors in other ways. The validation plugin accepts a selector to specify a dependency, whether an input is required or not: emailrules: { required: &quot;#email:filled&quot; } This would make a checkbox with name “emailrules” required only if the user entered an email address in the email field, selected via its id, filtered via a custom selector “:filled” that the validation plugin provides. #13. EVENT DOM标准事件包括：blur, focus, load, resize, scroll, unload, beforeunload, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, change, select, submit, keydown, keypress, andkeyup #14. JQUERY JQUERY对象包含DOM元素的集合。比如$(‘p’)即返回所有… JQUERY对象行为类似数组，也有length属性，也可以通过index访问DOM元素集合中的某个。但是不是数组，不具备数组的某些方法，比如join()。 许多jQuery方法返回jQuery对象本身，所以可以采用链式调用： $(&quot;p&quot;).css(&quot;color&quot;, &quot;red&quot;).find(&quot;.special&quot;).css(&quot;color&quot;, &quot;green&quot;); 但是如果你调用的方法会破坏jQuery对象，比如find()和filter()，则返回的不是原对象。要返回到原对象只需要再调用end()方法即可。","categories":[],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"一些好用的JQuery技巧","slug":"JqSkill","date":"2016-10-14T10:10:16.000Z","updated":"2016-10-19T01:09:40.501Z","comments":true,"path":"2016/10/14/JqSkill/","link":"","permalink":"http://yoursite.com/2016/10/14/JqSkill/","excerpt":"#一、返回顶部按钮 通过使用jQuery中的animate 和scrollTop 方法，不用插件就可以创建一个滚动到顶部的简单动画： // Back to top $(&apos;.top&apos;).click(function (e) { e.preventDefault(); $(&apos;html, body&apos;).animate({scrollTop: 0}, 800); }); &lt;!-- Create an anchor tag --&gt; &lt;a class=&quot;top&quot; href=&quot;#&quot;&gt;Back to top&lt;/a&gt; 改变scrollTop 的值可以更改你想要放置滚动条的位置。所有你真正需要做的是在800毫秒的时间内设置文档主体的动画，直到它滚动到文档的顶部。注：小心scrollTop的一些错误行为。 #二、预加载图像 如果你的网页要使用大量开始不可见的（例如，悬停的）图像，那么可以预加载这些图像： $.preloadImages = function () { for (var i = 0; i &lt; arguments.length; i++) { $(&apos;&lt;img&gt;&apos;).attr(&apos;src&apos;, arguments[i]); } }; $.preloadImages(&apos;img/hover-on.png&apos;, &apos;img/hover-off.png&apos;);","text":"#一、返回顶部按钮 通过使用jQuery中的animate 和scrollTop 方法，不用插件就可以创建一个滚动到顶部的简单动画： // Back to top $(&apos;.top&apos;).click(function (e) { e.preventDefault(); $(&apos;html, body&apos;).animate({scrollTop: 0}, 800); }); &lt;!-- Create an anchor tag --&gt; &lt;a class=&quot;top&quot; href=&quot;#&quot;&gt;Back to top&lt;/a&gt; 改变scrollTop 的值可以更改你想要放置滚动条的位置。所有你真正需要做的是在800毫秒的时间内设置文档主体的动画，直到它滚动到文档的顶部。注：小心scrollTop的一些错误行为。 #二、预加载图像 如果你的网页要使用大量开始不可见的（例如，悬停的）图像，那么可以预加载这些图像： $.preloadImages = function () { for (var i = 0; i &lt; arguments.length; i++) { $(&apos;&lt;img&gt;&apos;).attr(&apos;src&apos;, arguments[i]); } }; $.preloadImages(&apos;img/hover-on.png&apos;, &apos;img/hover-off.png&apos;); #三、检查图像是否加载 有时为了继续脚本，你可能需要检查图像是否全部加载完毕： $(&apos;img&apos;).load(function () { console.log(&apos;image load successful&apos;); }); 你也可以用ID或类替换标签来检查某个特定的图像是否被加载。 #四、自动修复破坏的图像 逐个替换已经破坏的图像链接是非常痛苦的。不过，下面这段简单的代码可以帮助你： $(&apos;img&apos;).on(&apos;error&apos;, function () { if(!$(this).hasClass(&apos;broken-image&apos;)) { $(this).prop(&apos;src&apos;, &apos;img/broken.png&apos;).addClass(&apos;broken-image&apos;); } }); 即使没有任何断掉的链接，加上这一段代码也不会让你有任何损失。 #五、悬停切换类 假设你希望当用户将鼠标悬停在可点击的元素上时，它会改变颜色。那么你可以在用户悬停的时候添加类到元素中，反之则删除类： $(&apos;.btn&apos;).hover(function () { $(this).addClass(&apos;hover&apos;); }, function () { $(this).removeClass(&apos;hover&apos;); }); 你只需要添加必要的CSS即可。更简单的方法是使用toggleClass 方法： $(&apos;.btn&apos;).hover(function () { $(this).toggleClass(&apos;hover&apos;); }); 注：可能在这种情况下，CSS这种解决方案更快，不过了解这个方法很有必要。 #六、禁用输入字段 有时候，你可能想要禁用表格的提交按钮或它的某一项文字输入直到用户执行了特定操作（例如，勾选“我已阅读相关条款”复选框）。添加 disabled属性到你的输入就可以在你想要的时候才启用它： $(&apos;input[type=&quot;submit&quot;]&apos;).prop(&apos;disabled&apos;, true); 然后你只需要运行输入的prop 方法就可以了，不过disabled 的值要设置为false： $(&apos;input[type=&quot;submit&quot;]&apos;).prop(&apos;disabled&apos;, false); #七、停止加载链接 有时候，你既不需要链接到某个特定的网页，也不想要重新加载页面——你可能希望链接做点别的事情，例如说触发一些其他脚本。这就要在阻止默认动作上做文章了： $(&apos;a.no-link&apos;).click(function (e) { e.preventDefault(); }); #八、淡入/滑动切换 滑动和淡入都是我们用jQuery做动画的时候大量运用的东西。如果你只是想在用户点击之后展示一个元素的话，那么用fadeIn 和slideDown 方法就很完美。但是，如果你想要元素在第一次点击的时候出现，然后在第二次点击的时候消失的话，那么可以试试下面的代码： // Fade $(&apos;.btn&apos;).click(function () { $(&apos;.element&apos;).fadeToggle(&apos;slow&apos;); }); // Toggle $(&apos;.btn&apos;).click(function () { $(&apos;.element&apos;).slideToggle(&apos;slow&apos;); }); #九、简单的手风琴 这是一个可快速生成手风琴的简单方法： // Close all panels $(&apos;#accordion&apos;).find(&apos;.content&apos;).hide(); // Accordion $(&apos;#accordion&apos;).find(&apos;.accordion-header&apos;).click(function () { var next = $(this).next(); next.slideToggle(&apos;fast&apos;); $(&apos;.content&apos;).not(next).slideUp(&apos;fast&apos;); return false; }); 通过添加这个脚本，你真正需要做的仅仅是在页面上添加必要的HTML元素，这样它就可以运行工作了。 #十、让两个div高度相同 有时候，你需要让两个div无论包含什么内容都拥有相同的高度： $(&apos;.div&apos;).css(&apos;min-height&apos;, $(&apos;.main-div&apos;).height()); 设置 min-height，这意味着它可以比主div大但绝对不能比主div小。不过，还有一种更灵活的方法是遍历一组元素，然后将高度设置为最高的那个元素的高度： var $columns = $(&apos;.column&apos;); var height = 0; $columns.each(function () { if ($(this).height() &gt; height) { height = $(this).height(); } }); $columns.height(height); 如果你希望所有列的高度相同： var $rows = $(&apos;.same-height-columns&apos;); $rows.each(function () { $(this).find(&apos;.column&apos;).height($(this).height()); }); #十一、在新标签页/窗口打开外部链接 在一个新的浏览器tab或窗口中打开外部链接，并确保同一个来源的链接能在同一个tab或者窗口中打开： $(&apos;a[href^=&quot;http&quot;]&apos;).attr(&apos;target&apos;, &apos;_blank&apos;); $(&apos;a[href^=&quot;//&quot;]&apos;).attr(&apos;target&apos;, &apos;_blank&apos;); $(&apos;a[href^=&quot;&apos; + window.location.origin + &apos;&quot;]&apos;).attr(&apos;target&apos;, &apos;_self&apos;); 注意：window.location.origin 在IE10中无效。修复的时候要小心这个问题。 #十二、通过文本查找元素通过使用jQuery中的contains() 选择器，你可以找到元素内容的文本。如果文本不存在，那就隐藏该元素： var search = $(&apos;#search&apos;).val(); $(&apos;div:not(:contains(&quot;&apos; + search + &apos;&quot;))&apos;).hide(); 13、在改变Visibility时触发 当用户不再关注某个tab，或重新聚焦原来的那个tab上时，触发JavaScript： $(document).on(&apos;visibilitychange&apos;, function (e) { if (e.target.visibilityState === &quot;visible&quot;) { console.log(&apos;Tab is now in view!&apos;); } else if (e.target.visibilityState === &quot;hidden&quot;) { console.log(&apos;Tab is now hidden!&apos;); } }); #十三、AJAX调用错误处理 当Ajax调用返回404或500错误时，就执行错误处理程序。如果没有定义处理程序，其他的jQuery代码或会就此罢工。定义一个全局的Ajax错误处理程序： $(document).ajaxError(function (e, xhr, settings, error) { console.log(error); }); #十四、链式插件调用 jQuery允许“链式”插件的方法调用，以减轻反复查询DOM并创建多个jQuery对象的过程。比方说，下面的代码片段代表了你的插件方法调用： $(&apos;#elem&apos;).show(); $(&apos;#elem&apos;).html(&apos;bla&apos;); $(&apos;#elem&apos;).otherStuff(); 通过使用链式，可以大大改善： $(&apos;#elem&apos;) .show() .html(&apos;bla&apos;) .otherStuff(); 还有一种方法是在（前缀$）变量中高速缓存元素： var $elem = $(&apos;#elem&apos;); $elem.hide(); $elem.html(&apos;bla&apos;); $elem.otherStuff(); 链式和高速缓存的方法都是jQuery中可以让代码变得更短和更快的代最佳做法。","categories":[],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"Js调试工具，万能的Console","slug":"console","date":"2016-10-14T10:01:28.000Z","updated":"2016-10-14T10:08:23.864Z","comments":true,"path":"2016/10/14/console/","link":"","permalink":"http://yoursite.com/2016/10/14/console/","excerpt":"#一 、什么是 ConsoleConsole 是用于显示 JS和 DOM 对象信息的单独窗口。并且向 JS 中注入1个 console 对象，使用该对象 可以输出信息到 Console 窗口中。 #二、什么浏览器支持 Console很多人可能都知道 Chrome 和 FireFox(FireBug)中都支持 Console。而其他浏览器都支 持不好。比如 IE8 自带的开发工具虽然支持 Console，但功能比较单调，显示对象的时候都是显示 [Object,Object]，而且不能点击查看对象里面的属性。IE6、IE7 虽然可以安装 Developer Toolbar，但也 不支持 console。Safari、Opera 都支持 Console，但使用上都没有 FireBug和 Chrome 的方便。 现在firebug推出了firebuglite工具，可以让所有浏览器都支持Console功能，而且使用上和FireBug 几乎一样。 #三、为什么不直接使用 alert 或自己写的 log使用 alert 不是一样可以显示信息，调试程序吗？alert 弹出窗口会中断程序， 如果要在循环中显示信息，手点击关闭窗口都累死。而且 alert 显示对象永远显示为[object ]。 自己写的 log 虽然可以显示一些 object 信息，但很多功能支持都没有 console 好，看完后面 console 的介绍就知道了。 #四、Console.log(object[, object, …])Console.log 是最简单输出信息到 console 窗口的方法，支持多个参数，该方法会把 这些参数组合在一起显示，e.g：","text":"#一 、什么是 ConsoleConsole 是用于显示 JS和 DOM 对象信息的单独窗口。并且向 JS 中注入1个 console 对象，使用该对象 可以输出信息到 Console 窗口中。 #二、什么浏览器支持 Console很多人可能都知道 Chrome 和 FireFox(FireBug)中都支持 Console。而其他浏览器都支 持不好。比如 IE8 自带的开发工具虽然支持 Console，但功能比较单调，显示对象的时候都是显示 [Object,Object]，而且不能点击查看对象里面的属性。IE6、IE7 虽然可以安装 Developer Toolbar，但也 不支持 console。Safari、Opera 都支持 Console，但使用上都没有 FireBug和 Chrome 的方便。 现在firebug推出了firebuglite工具，可以让所有浏览器都支持Console功能，而且使用上和FireBug 几乎一样。 #三、为什么不直接使用 alert 或自己写的 log使用 alert 不是一样可以显示信息，调试程序吗？alert 弹出窗口会中断程序， 如果要在循环中显示信息，手点击关闭窗口都累死。而且 alert 显示对象永远显示为[object ]。 自己写的 log 虽然可以显示一些 object 信息，但很多功能支持都没有 console 好，看完后面 console 的介绍就知道了。 #四、Console.log(object[, object, …])Console.log 是最简单输出信息到 console 窗口的方法，支持多个参数，该方法会把 这些参数组合在一起显示，e.g： log 方法第一个参数支持类似 C 语言 printf 字符串替换模式，Log 支持下面几种替换模式： %s 代替字符串 %d 代替整数 %f 代替浮点值 %o 代替 Object #五、console.debug，info，warn，error这4种方法与log方法使用一模一样，只是显示的图标和文字颜色不一样. #六、console.assert(expression[, object, …])assert 方法类似于单元测试中的断言，当 expression 表达式为 false 的时候，输出后面的信息,e.g： 注：assert 方法在 firebuglite 不支持，Chrome 和 FireBug 支持 #七、console.clear()该方法清空 console 中的所有信息 (Chrome中不支持) #八、console.dirxml(node)把html元素的html代码打印出来,等同于log. #九、console.trace()trace 方法可以查看当前函数的调用堆栈信息，即当前函数是如何调用的，e.g: #十、console.group(object[, object, …]), groupCollapsed, groupEnd这3个函数用于把log等输出的信息进行分组，方便阅读查看。groupCollapsed 方法与 group 方法一样，只是显示的分组默认是折叠的. #十一、console.time(name)/console.timeEnd(name)我们经常需要测试 js 函数的执行时间，可能我们自己写代码在第1 条语句和 最后 1 条语句取当前时间相减。这组函数其实就实现了这样的功能，time(name)根据 name 创建 1 个新 的计时器。timeEnd(name)停止给定name 的计时器，并显示时间。 #十二、console.profile(name)/console.profileEnd()这组方法用于打开浏览器的分析器，用于分析这组函数之间的 js 执行情况， 注：firebuglite 不支持 profile 功能，Chrome 支持 profile，但分析的内容不详。 #十三、console.count([title])count 方法用于统计当前代码被执行过多少次，title 参数可以在次数前面输出额外的标题以帮助阅读。e.g: #十四、console.table(data)table 方法把data 对象用表格的方式显示出来，这在显示数组或者格式一样的JSON 对象的时候非常有用。注：table 只支持 FireBug，而且是在 firebug1.6+版本后才有。 总结： Console 是帮助我们学习和调试 JS的 1 个非常好工具，如果你以前没用过，哪现在就开始用它吧。你会发现它能帮你省很多开发时间的。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"教你分分钟学会javascript闭包操作","slug":"learningClosure","date":"2016-10-14T09:45:54.000Z","updated":"2016-10-14T09:59:11.532Z","comments":true,"path":"2016/10/14/learningClosure/","link":"","permalink":"http://yoursite.com/2016/10/14/learningClosure/","excerpt":"闭包，是javascript中独有的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMA规范给的定义，如果没有实战经验，你很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟学会闭包! #一、闭包–爱的初体验 在接触一个新技术的时候，我首先会做的一件事就是：找它的demo code。对于码农们来说，代码有时候比自然语言更能理解一个事物。 其实，闭包无处不在，比如：jQuery、zepto的主要代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包demo，好让你在大脑里产生闭包的画面： function A(){ function B(){ console.log(&quot;Hello Closure!&quot;); } return B; } var b = A(); b();//Hello Closure! //这是史上最简单的闭包，不能再简单了，再简单就不是闭包了! 有了初步的认识后，我们简单分析一下它和普通函数有什么不同，这样我们才能从“茫茫人海”中一眼认出“她”。","text":"闭包，是javascript中独有的一个概念，对于初学者来讲，闭包是一个特别抽象的概念，特别是ECMA规范给的定义，如果没有实战经验，你很难从定义去理解它。因此，本文不会对闭包的概念进行大篇幅描述，直接上干货，让你分分钟学会闭包! #一、闭包–爱的初体验 在接触一个新技术的时候，我首先会做的一件事就是：找它的demo code。对于码农们来说，代码有时候比自然语言更能理解一个事物。 其实，闭包无处不在，比如：jQuery、zepto的主要代码都包含在一个大的闭包中，所以下面我先写一个最简单最原始的闭包demo，好让你在大脑里产生闭包的画面： function A(){ function B(){ console.log(&quot;Hello Closure!&quot;); } return B; } var b = A(); b();//Hello Closure! //这是史上最简单的闭包，不能再简单了，再简单就不是闭包了! 有了初步的认识后，我们简单分析一下它和普通函数有什么不同，这样我们才能从“茫茫人海”中一眼认出“她”。 上面代码翻译成自然语言如下： （1）定义了一个普通函数A （2）在A中定义了普通函数B （3）在A中返回B （4）执行A(),把A的返回结果赋值给变量b （5）执行b() 把这5步操作总结成一句扯淡的话就是：函数A的内部函数B被函数A外的一个变量b引用 把这句扯淡的话再加工一下就变成了闭包的定义：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 不要刻意去记住这个定义，我告诉你这个定义的目的是想让你理解上面的5步操作就是在阐述闭包的定义。因此，当你执行了上述5步操作的时候，你就已经定义了一个闭包! 这就是闭包。 #二、 闭包的作用 在了解闭包的作用之前，我们先了解一下javascript中的GC机制:在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回 收，否则这个对象一直会保存在内存中。 在上述例子中，B定义在A中，因此B依赖于A,而外部变量b又引用了B, 所以A间接的被b引用，也就是说，A不会被GC回 收，会一直保存在内存中。为了证明我们的推理，上面的例子稍作改进： function A(){ var count = 0; function B(){ count ++; console.log(count); } return B; } var b = A(); b();// 1 b();// 2 b();// 3 count是A中的一个变量，它的值在B中被改变，B每执行一次，count的值就在原来的基础上累加1。因此，A中的count一直保存在内存中。 这就是闭包的作用，有时候我们需要一个模块中定义这样一个变量：希望这个变量一直保存在内存中但又不会“污染”全局的变量，这个时候，我们就可以用闭包来定义这个模块。 #三、高端写法 上面的写法其实是最简单最原始的写法，而在实际应用中，没人这么玩，特别是在一些大型JS框架中更不会这么写。我之所以还要告诉你这种写法，是因为干扰因素越少越容易专注于一件事。下面我用常用的写法来写一个简单的demo组件： (function(document){ var viewport; var obj = { init:function(id){ viewport = document.querySelector(&quot;#&quot;+id); }, addChild:function(child){ viewport.appendChild(child); }, removeChild:function(child){ viewport.removeChild(child); } } window.jView = obj; })(document); 这个组件的作用是：初始化一个容器，然后可以给这个容器添加子容器，也可以移除一个容器。功能很简单，但这里涉及到了另外一个概念：立即执行函数。 简单了解一下就行。主要是要理解这种写法是怎么实现闭包功能的。 可以将上面的代码结构分成两部分： (function(){})() //红色部分是一个表达式，而这个表达式本身是一个匿名函数，所以在这个表达式后面加()就表示执行这个匿名函数。 因此这段代码执行执行过程可以分解如下： var f = function(document){ var viewport; var obj = { init:function(id){ viewport = document.querySelector(&quot;#&quot;+id); }, addChild:function(child){ viewport.appendChild(child); }, removeChild:function(child){ viewport.removeChild(child); } } window.jView = obj; }; f(document); 在这段代码中似乎看到了闭包的影子，但 f 中没有任何返回值，似乎不具备闭包的条件，注意这句代码：window.jView = obj; obj 是在 f 中定义的一个对象，这个对象中定义了一系列方法， 执行window.jView = obj 就是在 window 全局对象定义了一个变量 jView，并将这个变量指向 obj 对象，即全局变量 jView 引用了 obj . 而 obj 对象中的函数又引用了 f 中的变量 viewport ,因此 f 中的 viewport 不会被GC回 收，会一直保存到内存中，所以这种写法满足闭包的条件。 #四 简单的总结语 这是对闭包最简单的理解，当然闭包还有其更深层次的理解，这个就涉及的多了，你需要了解JS的执行环境(execution context)、活动对象(call object)以及作用域(scope)和作用域链(scope chain)的运行机制。但作为一个初学者，暂时不必了解这些，有了简单的理解之后，一定要在实际项目中用起来，等你用的多了，对于闭包，你自然会有更深层次的理解!","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"手机端html5触屏事件(touch事件)","slug":"touchEvent","date":"2016-10-14T09:35:03.000Z","updated":"2016-10-14T09:42:52.833Z","comments":true,"path":"2016/10/14/touchEvent/","link":"","permalink":"http://yoursite.com/2016/10/14/touchEvent/","excerpt":"touchstart：触摸开始的时候触发touchmove：手指在屏幕上滑动的时候触发touchend：触摸结束的时候触发 而每个触摸事件都包括了三个触摸列表，每个列表里包含了对应的一系列触摸点（用来实现多点触控）：touches：当前位于屏幕上的所有手指的列表。targetTouches：位于当前DOM元素上手指的列表。changedTouches：涉及当前事件手指的列表。","text":"touchstart：触摸开始的时候触发touchmove：手指在屏幕上滑动的时候触发touchend：触摸结束的时候触发 而每个触摸事件都包括了三个触摸列表，每个列表里包含了对应的一系列触摸点（用来实现多点触控）：touches：当前位于屏幕上的所有手指的列表。targetTouches：位于当前DOM元素上手指的列表。changedTouches：涉及当前事件手指的列表。 每个触摸点由包含了如下触摸信息（常用）：identifier：一个数值，唯一标识触摸会话（touch session）中的当前手指。一般为从0开始的流水号（android4.1，uc）target：DOM元素，是动作所针对的目标。pageX/pageX/clientX/clientY/screenX/screenY：一个数值，动作在屏幕上发生的位置（page包含滚动距离,client不包含滚动距离，screen则以屏幕为基准）。radiusX/radiusY/rotationAngle：画出大约相当于手指形状的椭圆形，分别为椭圆形的两个半径和旋转角度。初步测试浏览器不支持，好在功能不常用，欢迎大家反馈。 var obj = document.getElementByIdx_x(&apos;id&apos;); obj.addEventListener(&apos;touchmove&apos;, function(event) { // 如果这个元素的位置内只有一个手指的话 if (event.targetTouches.length == 1) { event.preventDefault(); // 阻止浏览器默认事件，重要 var touch = event.targetTouches[0]; // 把元素放在手指所在的位置 obj.style.left = touch.pageX-50 + &apos;px&apos;; obj.style.top = touch.pageY-50 + &apos;px&apos;; } }, false); 注意：此功能只能在移动设备或模拟移动设备查看效果","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://yoursite.com/tags/HTML5/"}]},{"title":"js闭包详解","slug":"detailedClosure","date":"2016-10-13T07:50:38.000Z","updated":"2016-10-14T09:59:58.855Z","comments":true,"path":"2016/10/13/detailedClosure/","link":"","permalink":"http://yoursite.com/2016/10/13/detailedClosure/","excerpt":"闭包有三个特性：1.函数嵌套函数2.函数内部可以引用外部的参数和变量3.参数和变量不会被垃圾回收机制回收闭包的定义及其优缺点 闭包 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量 使用闭包有一个优点，也是它的缺点，就是可以把局部变量驻留在内存中，可以避免使用全局变量。全局变量在每个模块都可调用，这势必将是灾难性的。（所以推荐使用私有的，封装的局部变量。）","text":"闭包有三个特性：1.函数嵌套函数2.函数内部可以引用外部的参数和变量3.参数和变量不会被垃圾回收机制回收闭包的定义及其优缺点 闭包 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量 使用闭包有一个优点，也是它的缺点，就是可以把局部变量驻留在内存中，可以避免使用全局变量。全局变量在每个模块都可调用，这势必将是灾难性的。（所以推荐使用私有的，封装的局部变量。） 一般函数执行完毕后，局部活动对象就被销毁，内存中仅仅保存全局作用域。但闭包的情况不同！ 嵌套函数的闭包 function aaa() { var a = 1; return function(){ alert(a++) }; } var fun = aaa(); fun();// 1 执行后 a++，，然后a还在~ fun();// 2 fun = null;//a被回收！！ 闭包会使变量始终保存在内存中，如果不当使用会增大内存消耗。 javascript的垃圾回收原理 （1）、在javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收；（2）、如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。 使用闭包的好处 那么使用闭包有什么好处呢？使用闭包的好处是： 1.希望一个变量长期驻扎在内存中2.避免全局变量的污染3.私有成员的存在 #一、全局变量的累加 var a = 1; function abc(){ a++; alert(a); } abc(); //2 abc(); //3 #二、局部变量 function abc(){ var a = 1; a++; alert(a); } abc(); //2 abc(); //2 那么怎么才能做到变量a既是局部变量又可以累加呢？ #三、局部变量的累加 function outer(){ var x=10; return function(){ //函数嵌套函数 x++; alert(x); } } var y = outer(); //外部函数赋给变量y; y(); //y函数调用一次，结果为11，相当于outer()()； y(); //y函数调用第二次，结果为12，实现了累加 函数声明与函数表达式 在js中我们可以通过关键字function来声明一个函数： function abc(){ alert(123); } abc(); 我们也可以通过一个”()”来将这个声明变成一个表达式： (function (){ alert(123); })(); //然后通过()直接调用前面的表达式即可，因此函数可以不必写名字； #四、模块化代码，减少全局变量的污染 var abc = (function(){ //abc为外部匿名函数的返回值 var a = 1; return function(){ a++; alert(a); } })(); abc(); //2 调用一次abc函数，其实是调用里面内部函数的返回值 abc(); //3 #五、私有成员的存在 var aaa = (function(){ var a = 1; function bbb(){ a++; alert(a); } function ccc(){ a++; alert(a); } return { b:bbb,//json结构 c:ccc } })(); aaa.b(); //2 aaa.c(); //3 #六.使用匿名函数实现累加使用匿名函数实现局部变量驻留内存中，从而实现累加 function box(){ var age = 100; return function(){ //匿名函数 age++; return age; }; }; var b = box(); alert(b()); alert(b()); //即alert(box()())； alert(b()); alert(b); function () { age++; return age; } b = null； //解除引用，等待垃圾回收 过度使用闭包会导致性能的下降。函数里放匿名函数，则产生了闭包 #七、在循环中直接找到对应元素的索引 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var aLi = document.getElementsByTagName(&apos;li&apos;); for (var i=0;i&lt;aLi.length;i++){ aLi[i].onclick = function(){ //当点击时for循环已经结束 alert(i); }; }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;456&lt;/li&gt; &lt;li&gt;789&lt;/li&gt; &lt;li&gt;010&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; #八、使用闭包改写上面代码 &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; var aLi = document.getElementsByTagName(&apos;li&apos;); for (var i=0;i&lt;aLi.length;i++){ (function(i){ aLi[i].onclick = function(){ alert(i); }; })(i); } }; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;123&lt;/li&gt; &lt;li&gt;456&lt;/li&gt; &lt;li&gt;789&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; #九.内存泄露问题 由于IE的js对象和DOM对象使用不同的垃圾收集方法，因此闭包在IE中会导致内存泄露问题，也就是无法销毁驻留在内存中的元素 function closure(){ var oDiv = document.getElementById(&apos;oDiv&apos;);//oDiv用完之后一直驻留在内存中 oDiv.onclick = function () { alert(&apos;oDiv.innerHTML&apos;);//这里用oDiv导致内存泄露 }; } closure(); //最后应将oDiv解除引用来避免内存泄露 function closure(){ var oDiv = document.getElementById(&apos;oDiv&apos;); var test = oDiv.innerHTML; oDiv.onclick = function () { alert(test); }; oDiv = null; } #十.思考题 如果你能理解下面代码的运行结果，应该就算理解闭包的运行机制了。 var name = &quot;trigkit4&quot;; var segmentFault = { name : &quot;My SF&quot;, getNameFunc : function(){ return function(){ return this.name; }; } }; //alert(segmentFault.getNameFunc()()); //弹出trigkit4","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]}