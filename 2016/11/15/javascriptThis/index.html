





<!doctype html>
<html lang="">

<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
<script type="text/javascript" 
src="//cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js">
</script>
<link href=  "/plugins/code-theme/tomorrow.css" type="text/css" rel="stylesheet" />
<link rel="stylesheet" href="/plugins/github-markdown.css">

<head>
  <meta charset="UTF-8">
  
    
    
      <link rel="stylesheet" href="/css/legend.css">
    
  
</head>

<body id="body-x">
<div id="layout-content">
  <div id="menu-outer-x">
  <div id="menu-inner">
    
    
    <div id="site-title">
      吴佳博客
    </div>
    

     
    <div>
    
      
      <a href="/">首页</a>
      
    
      
      <a href="/archives">归档</a>
      
    
    </div>
  </div>
</div> 
  <div id="content-outer">
    <div id="content-inner">
      
      
  <article class="markdown-body">
    <h1 id="post-title">学会JS的this这一篇就够了，根本不用记
       
        <div id="post-time" datetime="2016-11-15T01:04:33.000Z">
          2016-11-15
        </div>
      
    </h1>
    <p>#以前看某本书上讲：<br>掌握了JS中this的用法才算真正的跨过了JS的门槛<br>我深以为是！但是JS的this却并不是那么简单的内容，许多同学都很困惑，也肯定有同学像我曾经一样查阅各种资料想知道How to understand this of javascript。很幸运的是，网上有非常非常多的文章关于this的，简直就是琳琅满目…曾经，我看到某些文章非常开心，因为他们讲得确实非常好，以至于我确信我已掌握了this的用法。然而可能是由于我太笨了，经常过一段时间就忘得一干二净了，这真的是一件很尴尬的事情……直到后来我仔细地琢磨又琢磨，终于感觉我可能以后不会再忘记了。所以想把我琢磨的内容和大家分享一下。</p>
<p>说到this，就不得不提到function，相信看过其它类似文章的同学也知道，正是由于调用function的对象不同，才导致了this的指向不同。所以以前老是去记忆每种调用function的情况所对应的this，因为情况有限而且很少，所以这当然是可行的——对于聪明人来说。所以我不得不思考另外一些方式来让我记住。</p>
<p>那么首先我们需要明确的一个事情是：function也是对象<br>同时我们还需要明确的一个事情是：function执行时是在某个特定的上下文中执行的。那什么是上下文呢？打个比方，比如你练会了辟邪剑谱，那这时候你的掌门让你用辟邪剑谱砍人。如果仅仅是这样的话，你是没法完成这个任务的，因为你必须得知道要砍谁吧，其次去哪儿砍吧，那么是个地下通道还是一望无尽的大草原，要是地下通道你走路都困难，还怎么用辟邪剑谱呢对吧。这就是上下文，函数执行时它也需要一些额外的信息来支撑它的运行。那么既然function是对象的话，就会有方法。而function中最核心的方法是call方法。因此我们就从这儿入手。</p>
<p>#call方法<br>先来看一下如何使用call方法:</p>
<pre><code>function say(content) {
   console.log(&quot;From &quot; + this + &quot;: Hello &quot;+ content);
}
say.call(&quot;Bob&quot;, &quot;World&quot;); //==&gt; From Bob: Hello World
</code></pre><p>接下来仔细分析一下call的用法：<br>Step1: 把第二个到最后一个参数作为函数执行时要传入的参数<br>Step2: 把函数执行时的this指向第一个参数<br>Step3: 在上面这个特殊的上下文中执行函数<br>上面例子中，我们通过call方法，让say函数执行时的this指向”Bob”，然后把”World”作为参数传进去，所以输出结果是可以预见的。<br>js执行函数时会默认完成以上的步骤，你可以把直接调用函数理解为一种语法糖<br>比如：</p>
<pre><code>function say(word) {
   console.log(world);
}
say(&quot;Hello world&quot;);
say.call(window, &quot;Hello world&quot;);
</code></pre><p>以上可以把say(“Hello world”)看做是say.call(window,”Hello world”)的语法糖。</p>
<p>这个结论非常关键，所以以后每次看见functionName(xxx)的时候，你需要马上在脑海中把它替换为functionName.call(window,xxxx)，这对你理解this的指向非常重要。不过也有例外，在ES5的strict mode中call的第一个参数不是window而是undefined。之后的例子我假设总是不在strictmode下，但你需要记住strictmode有一点儿不同。<br>对于匿名函数来说，上面的结论也是成立的</p>
<pre><code>(function(name) {
    //
})(&quot;aa&quot;);
//等价于
(function(name) {    
  //
}).call(window, &quot;aa&quot;);
</code></pre><p>函数作为对象的方法被调用<br>直接来看代码：</p>
<pre><code>var person = {
    name : &quot;caibirdme&quot;,
    run : function(time) {
        console.log(this.name + &quot;has been running for over &quot;+ time+ &quot; minutes&quot;);
    }};
person.run(30);
//==&gt; caibirdme has been running for over 30 minutes//等价于
person.run.call(person, 30); // the same
</code></pre><p>你会发现这里call的第一个参数是person而不是window。<br>当你明白了这两点，下意识地把函数调用翻译成foo.call()的形式，明确call的第一个参数，那基本上this的问题就难不住你了。<br>还是来举几个例子吧</p>
<p>#例一：</p>
<pre><code>function hello(thing) {  
  console.log(this + &quot; says hello &quot; + thing);
}
  person = { name: &quot;caibirdme&quot; }  
  person.hello = hello;
  person.hello(&quot;world&quot;) 
// 相当于执行 person.hello.call(person, &quot;world&quot;)
hello(&quot;world&quot;) 
// 相当于执行 hello.call(window, &quot;world&quot;)
</code></pre><p>#例二：</p>
<pre><code>var obj = {
    x: 20,
    f: function(){ console.log(this.x); }
};
    obj.f(); // obj.f.call(obj)//==&gt; 20
obj.innerobj = {
    x: 30,
    f: function(){ console.log(this.x); }
}
obj.innerobj.f(); 
// obj.innerobj.f.call(obj.innerobj)// ==&gt; 30
</code></pre><p>#例三：</p>
<pre><code>var x = 10;
var obj = {
    x: 20,
    f: function(){
        console.log(this.x); //this equals obj
                // ==&gt; 20
        var foo = function(){ console.log(this.x); }
        foo(); 
        // foo.call(window)
        //foo中this被指定为window，所以==&gt; 10
    }
};
obj.f();  // obj.f.call(obj)// ==&gt; 20 10
</code></pre><p>由例三引出一个非常common的问题，如果我想让foo输出20怎么办？这时候需要用到一点小技巧</p>
<p>#例四：</p>
<pre><code>var x = 10;
var obj = {
    x: 20,
    f: function(){
        console.log(this.x);
        var that = this; 
//使用that保留当前函数执行上下文的this
        var foo = function(){ console.log(that.x); } 
//此时foo函数中的this仍然指向window，但我们使用that取得obj
        foo(); // foo.call(window)
    }
};
obj.f(); 
obj.f.call(obj)// ==&gt; 20 20
</code></pre><p>再来一个稍微难一点点的(但其实用call替换法一点儿也不难)</p>
<p>#例五：</p>
<pre><code>var x = 10;
var obj = {
    x: 20,
    f: function(){ console.log(this.x); }
};
obj.f(); // obj.f.call(obj)// ==&gt; 20
var fOut = obj.f;
fOut(); 
// fOut.call(window)//==&gt; 10
var obj2 = {
    x: 30,
    f: obj.f
}
obj2.f(); // obj2.f.call(obj2)//==&gt; 30
</code></pre><p>例五有些同学会可能出错的原因，是没有明确我上面说的：<br>this是在执行是才会被确认的<br>他可能会认为说obj.f那个函数定义在obj里面，那this就该指向obj。如果看完这篇文章你还这么想的话，我会觉得我的表达水平太失败了……<br>用于构造函数<br>先看一段代码：</p>
<pre><code>func person(name) {
    this.name = name;}
    var caibirdme = new person(&quot;deen&quot;);
    // caibirdme.name == deen
</code></pre><p>我上面也说了，函数在用作构造函数时同样可以用call方法去代替，那这里怎么代替呢？<br>这里你又需要明确一点：<br>new constrcut()是一种创建对象的语法糖<br>它等价于</p>
<pre><code>function person(name) {
   this.name = name;
}
var foo = new person(&quot;deen&quot;);
//通过new创建了一个对象
//new是一种语法糖，new person等价于
var bar = (function(name) {
    var _newObj = {
        constructor : person,
        __proto__ : person.prototype,
    };
    _newObj.constructor(name);
     // _newObj.constructor.call(_newObj, name)
    return _newObj;
})();
</code></pre><p>So you can see……为什么new的时候this就指向新的对象了吧？<br>通过我这篇文章，我希望学会通过把一个函数调用替换成funcName.call的形式，从而理解运行时上下文中this到底指向谁。总结来说就是下面两个等价变形：</p>
<pre><code>foo() ---&gt; foo.call(window)
obj.foo() --&gt; obj.foo.call(obj)
</code></pre><p>只要理解以上两个变形，this就不再是问题啦！！希望我的这种方法对各位同学认识this有所帮助，不要再像我曾经一样掉入this的坑中，相关面试题也不再怕怕啦，哈哈。</p>
<p>（想了想，还是给朋友们说下我自己的理解吧，this：当前执行环境的上下文，call和apply：修改对象的上下文）</p>

  </article>

  
    
    
      <div id="page-prev-next">
        
        
          <a id="page-prev-a" href="/2016/12/01/stringTurnNumber/"> ← JavaScript字符串转换为数字的方法 </a>
        

        
        
          <a id="page-next-a" href="/2016/11/08/jsapi/"> JavaScript常用API总结 → </a>
        
      </div>
    
    
    
    
      
      <div id="play-button"  style="background-color: #6d5aca; border: solid 2px #6d5aca;">
  <img id="play-img" src="/images/playback_play.png"></img>
</div>
<audio id="bgaudio" loop="loop" preload="none"> 
  <source src=http://cdn.calm.com/scenes/scene-Qqkzy9k7Eo.m4a?v=1418162240715 type="audio/mpeg">
</audio>

<script>
$(document).ready(function(){
  //播放按钮点击
  var audio = $("#bgaudio")[0];
  var img = $("#play-img")[0];
  $("#play-button").click(function(){ 
    if (audio.paused || audio.ended) {
      audio.play();
      img.src = "/images/playback_pause.png";
    } else {
      audio.pause();
      img.src = "/images/playback_play.png";
    }
  });
});
</script>
    

    
    

  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div id="reward_comment">文章对我有帮助，打赏作者</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechatpay.png" alt="吴佳 WeChat Pay"/>
          <p>微信</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.png" alt="吴佳 Alipay"/>
          <p>支付宝</p>
        </div> 
      
    </div>
  </div>


  

    </div>

    <!-- 多说评论框 -->    
    
      <div class="ds-thread" data-thread-key="2016/11/15/javascriptThis/" data-title="学会JS的this这一篇就够了，根本不用记" data-url="http://yoursite.com/2016/11/15/javascriptThis/"></div>
    
  </div>
</div>

<div id="bottom-outer">
  
  <div id="bottom-inner">
    吴佳 
    ©2016 |Powered by  
    <a href="http://hexo.io" target="_blank">Hexo</a> with theme 
    <a href="https://github.com/iHongRen/legend" target="_blank">legend</a>
  </div>
    
    
    
      <a href="/atom.xml">
      
      <img src=/images/rss.png height="18" width="18">
      
</div> 


  
  
    <script src="/js/legend.js"></script>
  


</body>
</html>



  
<script type="text/javascript">
var duoshuoQuery = {short_name:"ihongren"};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
   || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>



<script>
$(window).on('load', function(){
   $('pre').addClass('prettyprint').attr('style', 'overflow:auto;');
   prettyPrint();
 });
</script>

